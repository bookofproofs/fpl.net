# fpl Version 1.2.0

@@grammar::fpl
@@parseinfo :: True

# ----------------------------------------------------------------
# a mathematical theory written in FPL can be split between different files having
# the structure of the so-called theory part:

    # Every theory part block starts with an optional syntax extension block, followed by
    # optional usage of other libraries, followed by optional inference rules,
    # followed by a an optional uses block of comma-separated FplTheoryNamespace statements,
    # followed by a mandatory TheoryBlock, followed by an optional localization block
    Namespace =
        { CW }* NamespaceIdentifier
        { CW }* NamespaceBlock
        { CW }* $
        ;

    NamespaceBlock =
        LeftBrace
        { CW }* [ ExtensionBlock ]
        { CW }* [ UsesClause ]
        { CW }* [ RulesOfInferenceBlock ]
        { CW }* TheoryBlock
        { CW }* [ LocalizationBlock ]
        { CW }* RightBrace
        ;





    # A theory block is a sequence of statements
    TheoryBlock =
        TheoryHeader
        { CW }* LeftBrace
        { CW }* [ BuildingBlockList ]
        { CW }* RightBrace
        ;



    TheoryHeader =
        (
        theory
        | th
        )
        ;


    BuildingBlockList =
        BuildingBlock { { CW }* BuildingBlock }*
        ;

    # FPL statements can be definitions, axioms, Theorem-proof blocks and conjectures
    BuildingBlock =
        (
        Definition
        | Axiom
        | TheoremLikeStatementOrConjecture
        | Proof
        )
        ;


# ----------------------------------------------------------------
# Definitions

    Definition =
        (
        DefinitionClass
        | DefinitionPredicate
        | DefinitionFunctionalTerm
        )
        ;

    # Objects can only be defined with or without inheritance from a parent class cl
    DefinitionClass =
        ClassSignature
        { CW }* ObjectDefinitionBlock
        ;

    ClassSignature =
        ClassHeader
        SW PredicateIdentifier
        [ IW ] Colon
        [ IW ] Type
        ;

    ObjectDefinitionBlock =
        LeftBrace
        { CW }* [ VariableSpecificationList ]
        { CW }* [ DefinitionContentList ]
        { CW }* RightBrace
        ;

    FunctionalTermDefinitionBlock =
        LeftBrace
        { CW }* [ VariableSpecificationList ]
        { CW }* [ PropertyList ]
        { CW }* RightBrace
        ;

    DefinitionContentList =
        DefinitionContent { { CW }* DefinitionContent }*
        ;

    DefinitionContent =
        (
        Property
        | Constructor
        )
        ;

    DefinitionFunctionalTerm =
        FunctionalTermSignature
        { CW }* FunctionalTermDefinitionBlock
        ;








    # Predicates can be defined similarly to objects, but they are not derived from a parent type and have arguments
    DefinitionPredicate =
        PredicateHeader
        SW Signature
        { CW }* PredicateDefinitionBlock
        ;

    PredicateDefinitionBlock =
        LeftBrace
        { CW }* [ VariableSpecificationList ]
        { CW }* [ Predicate ]
        { CW }* [ PropertyList ]
        { CW }* RightBrace
        ;

    ClassHeader =
        (
        class
        | cl
        )
        ;










# -----------------------------------------------------
# Localization

    LocalizationBlock =
        LocalizationHeader
        { CW }* LeftBrace
        { CW }* LocalizationList
        { CW }* RightBrace
        ;

    LocalizationList =
        Localization { { CW }* Localization }*
        ;

    Localization =
        Predicate [ IW ] ColonEqual [ IW ] TranslationList [ IW ] SemiColon
        ;

    SemiColon =
        ";"
        ;

    Tilde =
        "~"
        ;

    TranslationList =
        Translation { SW Translation }*
        ;

    Translation =
        Tilde LanguageCode [ IW ] Colon [ IW ] EBNFTransl
        ;

    LanguageCode =
        /[a-z]{3}/
        ;

    EBNFTransl =
        EBNFTerm { [ IW ] EBNFBar [ IW ] EBNFTerm }*
        ;

    EBNFTerm =
        EBNFFactor { SW EBNFFactor }*
        ;

    EBNFFactor =
        (
        Variable
        | EBNFString
        | LeftParen [ IW ] EBNFTransl [ IW ] RightParen
        )
        ;

    EBNFString =
        /\"[^\"\n]*\"/
        ;

    EBNFBar =
        "|"
        ;

    LocalizationHeader =
        (
        localization
        | loc
        )
        ;


# -----------------------------------------------------
# Extensions of the FPL language (have to be dynamic)! Lacking a pre-processor, we put the rules
# from the Proof of Concept of FPL code manually into the EBNF of the core FPL grammar.

    # note that this has to be inserted into:
    # the IsOperand choice
    # the PredicateOrFunctionalTerm choice
    extDigits =
        /\d+/
        ;
