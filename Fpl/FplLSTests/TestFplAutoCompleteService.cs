using OmniSharp.Extensions.LanguageServer.Protocol.Models;
using FplLS;
using static FplGrammarTypes.Ast;
using static FplGrammarCommons;

namespace FplLSTests
{
    [TestClass]
    public class TestFplCompletionItem
    {
        [TestMethod]
        [DataRow("<some token>", "some token")]
        [DataRow("'token'", "token")]
        [DataRow("some token", "some token")]
        [DataRow("token", "token")]
        [DataRow("'token", "'token")]
        [DataRow("token'", "token'")]
        [DataRow("<token", "<token")]
        [DataRow("token>", "token>")]
        public void TestGetCompletionItemStrippingBracketsAndQuotes(string input, string expected)
        {
            var actual = FplCompletionItem.StripQuotesOrBrackets(input);
            Assert.AreEqual<string>(expected, actual);
        }

        [TestMethod]
        [DataRow("ax")]
        [DataRow("axiom")]
        [DataRow("post")]
        [DataRow("postulate")]
        [DataRow("thm")]
        [DataRow("theorem")]
        [DataRow("lem")]
        [DataRow("lemma")]
        [DataRow("prop")]
        [DataRow("proposition")]
        [DataRow("cor")]
        [DataRow("corollary")]
        [DataRow("ass")]
        [DataRow("assume")]
        [DataRow("cl")]
        [DataRow("class")]
        [DataRow("conj")]
        [DataRow("conjecture")]
        [DataRow("con")]
        [DataRow("conclusion")]
        [DataRow("ctor")]
        [DataRow("constructor")]
        [DataRow("dec")]
        [DataRow("declaration")]
        [DataRow("def")]
        [DataRow("definition")]
        [DataRow("del")]
        [DataRow("delegate")]
        [DataRow("ext")]
        [DataRow("extension")]
        [DataRow("func")]
        [DataRow("function")]
        [DataRow("ind")]
        [DataRow("index")]
        [DataRow("infix")]
        [DataRow("intr")]
        [DataRow("intrinsic")]
        [DataRow("inf")]
        [DataRow("inference")]
        [DataRow("loc")]
        [DataRow("localization")]
        [DataRow("mand")]
        [DataRow("mandatory")]
        [DataRow("obj")]
        [DataRow("object")]
        [DataRow("opt")]
        [DataRow("optional")]
        [DataRow("postfix")]
        [DataRow("pred")]
        [DataRow("predicate")]
        [DataRow("pre")]
        [DataRow("prefix")]
        [DataRow("premise")]
        [DataRow("prf")]
        [DataRow("proof")]
        [DataRow("ret")]
        [DataRow("return")]
        [DataRow("rev")]
        [DataRow("revoke")]
        [DataRow("symbol")]
        [DataRow("undef")]
        [DataRow("undefined")]
        public void TestGetCompletionItemLabels(string input)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>("_ " + input, actual.Label);
        }

        [TestMethod]
        [DataRow("ax", "axiom (short form)")]
        [DataRow("post", "postulate (short form)")]
        [DataRow("thm", "theorem (short form)")]
        [DataRow("lem", "lemma (short form)")]
        [DataRow("prop", "proposition (short form)")]
        [DataRow("cor", "corollary (short form)")]
        [DataRow("ass", "argument (assume, short form)")]
        [DataRow("cl", "class (short form)")]
        [DataRow("conj", "conjecture (short form)")]
        [DataRow("con", "conclusion (short form)")]
        [DataRow("ctor", "constructor (short form)")]
        [DataRow("dec", "declaration (short form)")]
        [DataRow("def", "definition (short form)")]
        [DataRow("del", "delegate (short form)")]
        [DataRow("func", "type (functional term, short form)")]
        [DataRow("ind", "type (index, short form)")]
        [DataRow("intr", "intrinsic (short form)")]
        [DataRow("inf", "rule of inference (short form)")]
        [DataRow("loc", "localization (short form)")]
        [DataRow("prty", "property (short form)")]
        [DataRow("obj", "type (object, short form)")]
        [DataRow("opt", "optional (short form)")]
        [DataRow("pred", "type (predicate, short form)")]
        [DataRow("pre", "premise (short form)")]
        [DataRow("prf", "proof (short form)")]
        [DataRow("ret", "statement (return, short form)")]
        [DataRow("rev", "argument (revoke, short form)")]
        [DataRow("undef", "undefined (short form)")]
        public void TestGetDetailShortForms(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>(expected, actual.Detail);
        }

        [TestMethod]
        [DataRow("axiom", "axiom")]
        [DataRow("postulate", "postulate")]
        [DataRow("theorem", "theorem")]
        [DataRow("lemma", "lemma")]
        [DataRow("proposition", "proposition")]
        [DataRow("corollary", "corollary")]
        [DataRow("assume", "argument (assume)")]
        [DataRow("class", "class")]
        [DataRow("conjecture", "conjecture")]
        [DataRow("conclusion", "conclusion")]
        [DataRow("constructor", "constructor")]
        [DataRow("declaration", "declaration")]
        [DataRow("definition", "definition")]
        [DataRow("delegate", "delegate")]
        [DataRow("extension", "extension")]
        [DataRow("function", "type (functional term)")]
        [DataRow("index", "type (index)")]
        [DataRow("intrinsic", "intrinsic")]
        [DataRow("inference", "rule of inference")]
        [DataRow("localization", "localization")]
        [DataRow("property", "property")]
        [DataRow("object", "type (object)")]
        [DataRow("optional", "optional")]
        [DataRow("predicate", "type (predicate)")]
        [DataRow("premise", "premise")]
        [DataRow("proof", "proof")]
        [DataRow("return", "statement (return)")]
        [DataRow("revoke", "argument (revoke)")]
        [DataRow("undefined", "undefined")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, "predicate (all quantor)")]
        [DataRow("and", "predicate (conjunction)")]
        [DataRow("assert", "statement (assert)")]
        [DataRow("cases", "statement (cases)")]
        [DataRow("ex", "predicate (exists quantor)")]
        [DataRow("exn", "predicate (exists n-times quantor)")]
        [DataRow("false", "predicate (false)")]
        [DataRow("for", "statement (for loop)")]
        [DataRow("iif", "predicate (equivalence, <=>)")]
        [DataRow("impl", "predicate (implication, =>)")]
        [DataRow("in", "clause (in type or in range)")]
        [DataRow("infix", "infix operator")]
        [DataRow("is", "predicate (is of type)")]
        [DataRow("not", "predicate (negation)")]
        [DataRow("or", "predicate (disjunction)")]
        [DataRow("prefix", "prefix operator")]
        [DataRow("postfix", "postfix operator")]
        [DataRow("qed", "(quod erat demonstrandum)")]
        [DataRow("self", "reference (to self)")]
        [DataRow("parent", "reference (to parent)")]
        [DataRow("symbol", "object symbol")]
        [DataRow("trivial", "argument (trivial)")]
        [DataRow("true", "predicate (true)")]
        [DataRow("uses", "clause (uses)")]
        [DataRow("xor", "predicate (exclusive or)")]
        public void TestGetDetailLongForms(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>(expected, actual.Detail);
        }


        [TestMethod]
        [DataRow("ax", CompletionItemKind.Class)]
        [DataRow("axiom", CompletionItemKind.Class)]
        [DataRow("post", CompletionItemKind.Class)]
        [DataRow("postulate", CompletionItemKind.Class)]
        [DataRow("thm", CompletionItemKind.Class)]
        [DataRow("theorem", CompletionItemKind.Class)]
        [DataRow("lem", CompletionItemKind.Class)]
        [DataRow("lemma", CompletionItemKind.Class)]
        [DataRow("prop", CompletionItemKind.Class)]
        [DataRow("proposition", CompletionItemKind.Class)]
        [DataRow("cor", CompletionItemKind.Class)]
        [DataRow("corollary", CompletionItemKind.Class)]
        [DataRow("ass", CompletionItemKind.Property)]
        [DataRow("assume", CompletionItemKind.Property)]
        [DataRow("cl", CompletionItemKind.TypeParameter)]
        [DataRow("class", CompletionItemKind.TypeParameter)]
        [DataRow("conj", CompletionItemKind.Class)]
        [DataRow("conjecture", CompletionItemKind.Class)]
        [DataRow("con", CompletionItemKind.Struct)]
        [DataRow("conclusion", CompletionItemKind.Struct)]
        [DataRow("ctor", CompletionItemKind.Constructor)]
        [DataRow("constructor", CompletionItemKind.Constructor)]
        [DataRow("dec", CompletionItemKind.Property)]
        [DataRow("declaration", CompletionItemKind.Property)]
        [DataRow("def", CompletionItemKind.Class)]
        [DataRow("definition", CompletionItemKind.Class)]
        [DataRow("del", CompletionItemKind.Event)]
        [DataRow("delegate", CompletionItemKind.Event)]
        [DataRow("ext", CompletionItemKind.Class)]
        [DataRow("extension", CompletionItemKind.Class)]
        [DataRow("func", CompletionItemKind.TypeParameter)]
        [DataRow("function", CompletionItemKind.TypeParameter)]
        [DataRow("ind", CompletionItemKind.TypeParameter)]
        [DataRow("index", CompletionItemKind.TypeParameter)]
        [DataRow("intr", CompletionItemKind.Struct)]
        [DataRow("intrinsic", CompletionItemKind.Struct)]
        [DataRow("inf", CompletionItemKind.Class)]
        [DataRow("inference", CompletionItemKind.Class)]
        [DataRow("loc", CompletionItemKind.Class)]
        [DataRow("localization", CompletionItemKind.Class)]
        [DataRow("prty", CompletionItemKind.Value)]
        [DataRow("property", CompletionItemKind.Value)]
        [DataRow("obj", CompletionItemKind.TypeParameter)]
        [DataRow("object", CompletionItemKind.TypeParameter)]
        [DataRow("opt", CompletionItemKind.Property)]
        [DataRow("optional", CompletionItemKind.Property)]
        [DataRow("pred", CompletionItemKind.TypeParameter)]
        [DataRow("predicate", CompletionItemKind.TypeParameter)]
        [DataRow("pre", CompletionItemKind.Struct)]
        [DataRow("premise", CompletionItemKind.Struct)]
        [DataRow("prf", CompletionItemKind.Class)]
        [DataRow("proof", CompletionItemKind.Class)]
        [DataRow("ret", CompletionItemKind.Property)]
        [DataRow("return", CompletionItemKind.Property)]
        [DataRow("rev", CompletionItemKind.Property)]
        [DataRow("revoke", CompletionItemKind.Property)]
        [DataRow("undef", CompletionItemKind.Constant)]
        [DataRow("undefined", CompletionItemKind.Constant)]
        // keywords without a short form
        [DataRow(literalAlias, CompletionItemKind.Struct)]
        [DataRow(literalAll, CompletionItemKind.Operator)]
        [DataRow("and", CompletionItemKind.Operator)]
        [DataRow("assert", CompletionItemKind.Property)]
        [DataRow("cases", CompletionItemKind.Property)]
        [DataRow("ex", CompletionItemKind.Operator)]
        [DataRow("exn", CompletionItemKind.Operator)]
        [DataRow("false", CompletionItemKind.Constant)]
        [DataRow("for", CompletionItemKind.Property)]
        [DataRow("iif", CompletionItemKind.Operator)]
        [DataRow("impl", CompletionItemKind.Operator)]
        [DataRow("in", CompletionItemKind.Property)]
        [DataRow("infix", CompletionItemKind.Operator)]
        [DataRow("is", CompletionItemKind.Interface)]
        [DataRow("not", CompletionItemKind.Operator)]
        [DataRow("or", CompletionItemKind.Operator)]
        [DataRow("postfix", CompletionItemKind.Operator)]
        [DataRow("prefix", CompletionItemKind.Operator)]
        [DataRow("qed", CompletionItemKind.Text)]
        [DataRow("self", CompletionItemKind.Reference)]
        [DataRow("parent", CompletionItemKind.Reference)]
        [DataRow("symbol", CompletionItemKind.TypeParameter)]
        [DataRow("trivial", CompletionItemKind.Text)]
        [DataRow("true", CompletionItemKind.Constant)]
        [DataRow("uses", CompletionItemKind.Module)]
        [DataRow("xor", CompletionItemKind.Operator)]
        public void TestGetDetailCompletionKind(string input, CompletionItemKind expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<CompletionItemKind>(expected, actual.Kind);
        }

        [TestMethod]
        [DataRow("ax", "axiom02")]
        [DataRow("axiom", "axiom01")]
        [DataRow("post", "postulate02")]
        [DataRow("postulate", "postulate01")]
        [DataRow("thm", "theorem02")]
        [DataRow("theorem", "theorem01")]
        [DataRow("lem", "lemma02")]
        [DataRow("lemma", "lemma01")]
        [DataRow("prop", "proposition02")]
        [DataRow("proposition", "proposition01")]
        [DataRow("cor", "corollary02")]
        [DataRow("corollary", "corollary01")]
        [DataRow("ass", "assume02")]
        [DataRow("assume", "assume01")]
        [DataRow("cl", "class02")]
        [DataRow("class", "class01")]
        [DataRow("conj", "conjecture02")]
        [DataRow("conjecture", "conjecture01")]
        [DataRow("con", "conclusion02")]
        [DataRow("conclusion", "conclusion01")]
        [DataRow("ctor", "constructor02")]
        [DataRow("constructor", "constructor01")]
        [DataRow("dec", "declaration02")]
        [DataRow("declaration", "declaration01")]
        [DataRow("def", "definition02")]
        [DataRow("definition", "definition01")]
        [DataRow("del", "delegate02")]
        [DataRow("delegate", "delegate01")]
        [DataRow("ext", "extension02")]
        [DataRow("extension", "extension01")]
        [DataRow("func", "function02")]
        [DataRow("function", "function01")]
        [DataRow("ind", "index02")]
        [DataRow("index", "index01")]
        [DataRow("intr", "intrinsic02")]
        [DataRow("intrinsic", "intrinsic01")]
        [DataRow("inf", "inference02")]
        [DataRow("inference", "inference01")]
        [DataRow("loc", "localization02")]
        [DataRow("localization", "localization01")]
        [DataRow("prty", "property02")]
        [DataRow("property", "property01")]
        [DataRow("obj", "object02")]
        [DataRow("object", "object01")]
        [DataRow("opt", "optional02")]
        [DataRow("optional", "optional01")]
        [DataRow("pred", "predicate02")]
        [DataRow("predicate", "predicate01")]
        [DataRow("pre", "premise02")]
        [DataRow("premise", "premise01")]
        [DataRow("prf", "proof02")]
        [DataRow("proof", "proof01")]
        [DataRow("ret", "return02")]
        [DataRow("return", "return01")]
        [DataRow("rev", "revoke02")]
        [DataRow("revoke", "revoke01")]
        [DataRow("undef", "undefined02")]
        [DataRow("undefined", "undefined01")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, literalAll)]
        [DataRow("and", "and")]
        [DataRow("assert", "assert")]
        [DataRow("cases", "cases")]
        [DataRow("ex", "ex")]
        [DataRow("exn", "exn")]
        [DataRow("false", "false")]
        [DataRow("for", "for")]
        [DataRow("iif", "iif")]
        [DataRow("impl", "impl")]
        [DataRow("in", "in")]
        [DataRow("infix", "infix")]
        [DataRow("is", "is")]
        [DataRow("not", "not")]
        [DataRow("or", "or")]
        [DataRow("prefix", "prefix")]
        [DataRow("postfix", "postfix")]
        [DataRow("qed", "qed")]
        [DataRow("self", "self")]
        [DataRow("parent", "parent")]
        [DataRow("symbol", "symbol")]
        [DataRow("trivial", "trivial")]
        [DataRow("true", "true")]
        [DataRow("uses", "uses")]
        [DataRow("xor", "xor")]
        public void TestGetCompletionItemSortTextsForKeywords(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Console.WriteLine(input);
            Assert.AreEqual<string>(expected, actual.SortText.Replace("zzz", ""));
        }

        [TestMethod]
        [DataRow("ax", "axiom02")]
        [DataRow("axiom", "axiom01")]
        [DataRow("post", "postulate02")]
        [DataRow("postulate", "postulate01")]
        [DataRow("thm", "theorem02")]
        [DataRow("theorem", "theorem01")]
        [DataRow("lem", "lemma02")]
        [DataRow("lemma", "lemma01")]
        [DataRow("prop", "proposition02")]
        [DataRow("proposition", "proposition01")]
        [DataRow("cor", "corollary02")]
        [DataRow("corollary", "corollary01")]
        [DataRow("ass", "assume02")]
        [DataRow("assume", "assume01")]
        [DataRow("cl", "class02")]
        [DataRow("class", "class01")]
        [DataRow("conj", "conjecture02")]
        [DataRow("conjecture", "conjecture01")]
        [DataRow("con", "conclusion02")]
        [DataRow("conclusion", "conclusion01")]
        [DataRow("ctor", "constructor02")]
        [DataRow("constructor", "constructor01")]
        [DataRow("dec", "declaration02")]
        [DataRow("declaration", "declaration01")]
        [DataRow("def", "definition02")]
        [DataRow("definition", "definition01")]
        [DataRow("del", "delegate02")]
        [DataRow("delegate", "delegate01")]
        [DataRow("ext", "extension02")]
        [DataRow("extension", "extension01")]
        [DataRow("func", "function02")]
        [DataRow("function", "function01")]
        [DataRow("ind", "index02")]
        [DataRow("index", "index01")]
        [DataRow("intr", "intrinsic02")]
        [DataRow("intrinsic", "intrinsic01")]
        [DataRow("inf", "inference02")]
        [DataRow("inference", "inference01")]
        [DataRow("loc", "localization02")]
        [DataRow("localization", "localization01")]
        [DataRow("prty", "property02")]
        [DataRow("property", "property01")]
        [DataRow("obj", "object02")]
        [DataRow("object", "object01")]
        [DataRow("opt", "optional02")]
        [DataRow("optional", "optional01")]
        [DataRow("pred", "predicate02")]
        [DataRow("predicate", "predicate01")]
        [DataRow("pre", "premise02")]
        [DataRow("premise", "premise01")]
        [DataRow("prf", "proof02")]
        [DataRow("proof", "proof01")]
        [DataRow("ret", "return02")]
        [DataRow("return", "return01")]
        [DataRow("rev", "revoke02")]
        [DataRow("revoke", "revoke01")]
        [DataRow("undef", "undefined02")]
        [DataRow("undefined", "undefined01")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, literalAll)]
        [DataRow("and", "and")]
        [DataRow("assert", "assert")]
        [DataRow("cases", "cases")]
        [DataRow("ex", "ex")]
        [DataRow("exn", "exn")]
        [DataRow("false", "false")]
        [DataRow("for", "for")]
        [DataRow("iif", "iif")]
        [DataRow("impl", "impl")]
        [DataRow("in", "in")]
        [DataRow("infix", "infix")]
        [DataRow("is", "is")]
        [DataRow("not", "not")]
        [DataRow("or", "or")]
        [DataRow("prefix", "prefix")]
        [DataRow("postfix", "postfix")]
        [DataRow("qed", "qed")]
        [DataRow("self", "self")]
        [DataRow("parent", "parent")]
        [DataRow("symbol", "symbol")]
        [DataRow("trivial", "trivial")]
        [DataRow("true", "true")]
        [DataRow("uses", "uses")]
        [DataRow("xor", "xor")]
        public void TestGetCompletionItemSortTextsForSnippets(string input, string expected)
        {
            var actual = new FplCompletionItem(input, "xxx");
            Console.WriteLine(input);
            Assert.AreEqual<string>(expected, actual.SortText);
        }


        [TestMethod]
        [DataRow("ax", true)]
        [DataRow("axiom", false)]
        [DataRow("post", true)]
        [DataRow("postulate", false)]
        [DataRow("thm", true)]
        [DataRow("theorem", false)]
        [DataRow("lem", true)]
        [DataRow("lemma", false)]
        [DataRow("prop", true)]
        [DataRow("proposition", false)]
        [DataRow("cor", true)]
        [DataRow("corollary", false)]
        [DataRow("ass", true)]
        [DataRow("assume", false)]
        [DataRow("cl", true)]
        [DataRow("class", false)]
        [DataRow("conj", true)]
        [DataRow("conjecture", false)]
        [DataRow("con", true)]
        [DataRow("conclusion", false)]
        [DataRow("ctor", true)]
        [DataRow("constructor", false)]
        [DataRow("dec", true)]
        [DataRow("declaration", false)]
        [DataRow("def", true)]
        [DataRow("definition", false)]
        [DataRow("del", true)]
        [DataRow("delegate", false)]
        [DataRow("ext", true)]
        [DataRow("extension", false)]
        [DataRow("func", true)]
        [DataRow("function", false)]
        [DataRow("ind", true)]
        [DataRow("index", false)]
        [DataRow("intr", true)]
        [DataRow("intrinsic", false)]
        [DataRow("inf", true)]
        [DataRow("inference", false)]
        [DataRow("loc", true)]
        [DataRow("localization", false)]
        [DataRow("prty", true)]
        [DataRow("property", false)]
        [DataRow("obj", true)]
        [DataRow("object", false)]
        [DataRow("opt", true)]
        [DataRow("optional", false)]
        [DataRow("pred", true)]
        [DataRow("predicate", false)]
        [DataRow("pre", true)]
        [DataRow("premise", false)]
        [DataRow("prf", true)]
        [DataRow("proof", false)]
        [DataRow("ret", true)]
        [DataRow("return", false)]
        [DataRow("rev", true)]
        [DataRow("revoke", false)]
        [DataRow("undef", true)]
        [DataRow("undefined", false)]
        // keywords without a short form
        [DataRow(literalAlias, false)]
        [DataRow(literalAll, false)]
        [DataRow("and", false)]
        [DataRow("assert", false)]
        [DataRow("cases", false)]
        [DataRow("ex", false)]
        [DataRow("exn", false)]
        [DataRow("false", false)]
        [DataRow("for", false)]
        [DataRow("iif", false)]
        [DataRow("impl", false)]
        [DataRow("in", false)]
        [DataRow("infix", false)]
        [DataRow("is", false)]
        [DataRow("not", false)]
        [DataRow("or", false)]
        [DataRow("prefix", false)]
        [DataRow("postfix", false)]
        [DataRow("qed", false)]
        [DataRow("self", false)]
        [DataRow("parent", false)]
        [DataRow("symbol", false)]
        [DataRow("trivial", false)]
        [DataRow("true", false)]
        [DataRow("uses", false)]
        [DataRow("xor", false)]
        public void TestGetDetailIsShort(string input, bool expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<bool>(expected, actual.IsShort);
        }
    }
}
