// Ignore Spelling: Fpl

using OmniSharp.Extensions.LanguageServer.Protocol.Models;
using FplLS;
using static FplGrammarTypes.Ast;
using static FplGrammarCommons;

namespace FplLSTests
{
    [TestClass]
    public class TestFplCompletionItem
    {
        [TestMethod]
        [DataRow("<some token>", "some token")]
        [DataRow("'token'", "token")]
        [DataRow("some token", "some token")]
        [DataRow("token", "token")]
        [DataRow("'token", "'token")]
        [DataRow("token'", "token'")]
        [DataRow("<token", "<token")]
        [DataRow("token>", "token>")]
        public void TestGetCompletionItemStrippingBracketsAndQuotes(string input, string expected)
        {
            var actual = FplCompletionItem.StripQuotesOrBrackets(input);
            Assert.AreEqual<string>(expected, actual);
        }

        [TestMethod]
        [DataRow(literalAx)]
        [DataRow(literalAxL)]
        [DataRow("post")]
        [DataRow("postulate")]
        [DataRow("thm")]
        [DataRow("theorem")]
        [DataRow("lem")]
        [DataRow("lemma")]
        [DataRow("prop")]
        [DataRow("proposition")]
        [DataRow(literalCor)]
        [DataRow(literalCorL)]
        [DataRow(literalAss)]
        [DataRow(literalAssume)]
        [DataRow(literalCl)]
        [DataRow(literalClL)]
        [DataRow(literalConj)]
        [DataRow(literalConjL)]
        [DataRow(literalCon)]
        [DataRow(literalConL)]
        [DataRow(literalCtor)]
        [DataRow(literalCtorL)]
        [DataRow(literalDec)]
        [DataRow(literalDecL)]
        [DataRow(literalDef)]
        [DataRow(literalDefL)]
        [DataRow(literalDel)]
        [DataRow(literalDelL)]
        [DataRow(literalExt)]
        [DataRow(literalExtL)]
        [DataRow(literalFunc)]
        [DataRow(literalFuncL)]
        [DataRow("ind")]
        [DataRow("index")]
        [DataRow("infix")]
        [DataRow("intr")]
        [DataRow("intrinsic")]
        [DataRow("inf")]
        [DataRow("inference")]
        [DataRow("loc")]
        [DataRow("localization")]
        [DataRow("mand")]
        [DataRow("mandatory")]
        [DataRow("obj")]
        [DataRow("object")]
        [DataRow("opt")]
        [DataRow("optional")]
        [DataRow("postfix")]
        [DataRow("pred")]
        [DataRow("predicate")]
        [DataRow("pre")]
        [DataRow("prefix")]
        [DataRow("premise")]
        [DataRow("prf")]
        [DataRow("proof")]
        [DataRow("ret")]
        [DataRow("return")]
        [DataRow("rev")]
        [DataRow("revoke")]
        [DataRow("symbol")]
        [DataRow("undef")]
        [DataRow("undefined")]
        public void TestGetCompletionItemLabels(string input)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>("_ " + input, actual.Label);
        }

        [TestMethod]
        [DataRow(literalAx, "axiom (short form)")]
        [DataRow("post", "postulate (short form)")]
        [DataRow("thm", "theorem (short form)")]
        [DataRow("lem", "lemma (short form)")]
        [DataRow("prop", "proposition (short form)")]
        [DataRow(literalCor, "corollary (short form)")]
        [DataRow(literalAss, "argument (assume, short form)")]
        [DataRow(literalCl, "class (short form)")]
        [DataRow(literalConj, "conjecture (short form)")]
        [DataRow(literalCon, "conclusion (short form)")]
        [DataRow(literalCtor, "constructor (short form)")]
        [DataRow(literalDec, "declaration (short form)")]
        [DataRow(literalDef, "definition (short form)")]
        [DataRow(literalDel, "delegate (short form)")]
        [DataRow(literalFunc, "type (functional term, short form)")]
        [DataRow("ind", "type (index, short form)")]
        [DataRow("intr", "intrinsic (short form)")]
        [DataRow("inf", "rule of inference (short form)")]
        [DataRow("loc", "localization (short form)")]
        [DataRow("prty", "property (short form)")]
        [DataRow("obj", "type (object, short form)")]
        [DataRow("opt", "optional (short form)")]
        [DataRow("pred", "type (predicate, short form)")]
        [DataRow("pre", "premise (short form)")]
        [DataRow("prf", "proof (short form)")]
        [DataRow("ret", "statement (return, short form)")]
        [DataRow("rev", "argument (revoke, short form)")]
        [DataRow("undef", "undefined (short form)")]
        public void TestGetDetailShortForms(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>(expected, actual.Detail);
        }

        [TestMethod]
        [DataRow(literalAxL, literalAxL)]
        [DataRow("postulate", "postulate")]
        [DataRow("theorem", "theorem")]
        [DataRow("lemma", "lemma")]
        [DataRow("proposition", "proposition")]
        [DataRow(literalCorL, literalCorL)]
        [DataRow(literalAssume, "argument (assume)")]
        [DataRow(literalClL, literalClL)]
        [DataRow(literalConjL, literalConjL)]
        [DataRow(literalConL, literalConL)]
        [DataRow(literalCtorL, literalCtorL)]
        [DataRow(literalDecL, literalDecL)]
        [DataRow(literalDefL, literalDefL)]
        [DataRow(literalDelL, literalDelL)]
        [DataRow(literalExtL, literalExtL)]
        [DataRow(literalFuncL, "type (functional term)")]
        [DataRow("index", "type (index)")]
        [DataRow("intrinsic", "intrinsic")]
        [DataRow("inference", "rule of inference")]
        [DataRow("localization", "localization")]
        [DataRow("property", "property")]
        [DataRow("object", "type (object)")]
        [DataRow("optional", "optional")]
        [DataRow("predicate", "type (predicate)")]
        [DataRow("premise", "premise")]
        [DataRow("proof", "proof")]
        [DataRow("return", "statement (return)")]
        [DataRow("revoke", "argument (revoke)")]
        [DataRow("undefined", "undefined")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, "predicate (all quantor)")]
        [DataRow(literalAnd, "predicate (conjunction)")]
        [DataRow(literalAssL, "statement (assert)")]
        [DataRow(literalCases, "statement (cases)")]
        [DataRow(literalEx, "predicate (exists quantor)")]
        [DataRow(literalExN, "predicate (exists n-times quantor)")]
        [DataRow(literalFalse, "predicate (false)")]
        [DataRow(literalFor, "statement (for loop)")]
        [DataRow("iif", "predicate (equivalence, <=>)")]
        [DataRow("impl", "predicate (implication, =>)")]
        [DataRow("in", "clause (in type or in range)")]
        [DataRow("infix", "infix operator")]
        [DataRow("is", "predicate (is of type)")]
        [DataRow("not", "predicate (negation)")]
        [DataRow("or", "predicate (disjunction)")]
        [DataRow("prefix", "prefix operator")]
        [DataRow("postfix", "postfix operator")]
        [DataRow("qed", "(quod erat demonstrandum)")]
        [DataRow("self", "reference (to self)")]
        [DataRow("parent", "reference (to parent)")]
        [DataRow("symbol", "object symbol")]
        [DataRow("trivial", "argument (trivial)")]
        [DataRow("true", "predicate (true)")]
        [DataRow("uses", "clause (uses)")]
        [DataRow("xor", "predicate (exclusive or)")]
        public void TestGetDetailLongForms(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>(expected, actual.Detail);
        }


        [TestMethod]
        [DataRow(literalAx, CompletionItemKind.Class)]
        [DataRow(literalAxL, CompletionItemKind.Class)]
        [DataRow("post", CompletionItemKind.Class)]
        [DataRow("postulate", CompletionItemKind.Class)]
        [DataRow("thm", CompletionItemKind.Class)]
        [DataRow("theorem", CompletionItemKind.Class)]
        [DataRow("lem", CompletionItemKind.Class)]
        [DataRow("lemma", CompletionItemKind.Class)]
        [DataRow("prop", CompletionItemKind.Class)]
        [DataRow("proposition", CompletionItemKind.Class)]
        [DataRow(literalCor, CompletionItemKind.Class)]
        [DataRow(literalCorL, CompletionItemKind.Class)]
        [DataRow(literalAss, CompletionItemKind.Property)]
        [DataRow(literalAssume, CompletionItemKind.Property)]
        [DataRow(literalCl, CompletionItemKind.TypeParameter)]
        [DataRow(literalClL, CompletionItemKind.TypeParameter)]
        [DataRow(literalConj, CompletionItemKind.Class)]
        [DataRow(literalConjL, CompletionItemKind.Class)]
        [DataRow(literalCon, CompletionItemKind.Struct)]
        [DataRow(literalConL, CompletionItemKind.Struct)]
        [DataRow(literalCtor, CompletionItemKind.Constructor)]
        [DataRow(literalCtorL, CompletionItemKind.Constructor)]
        [DataRow(literalDec, CompletionItemKind.Property)]
        [DataRow(literalDecL, CompletionItemKind.Property)]
        [DataRow(literalDef, CompletionItemKind.Class)]
        [DataRow(literalDefL, CompletionItemKind.Class)]
        [DataRow(literalDel, CompletionItemKind.Event)]
        [DataRow(literalDelL, CompletionItemKind.Event)]
        [DataRow(literalExt, CompletionItemKind.Class)]
        [DataRow(literalExtL, CompletionItemKind.Class)]
        [DataRow(literalFunc, CompletionItemKind.TypeParameter)]
        [DataRow(literalFuncL, CompletionItemKind.TypeParameter)]
        [DataRow("ind", CompletionItemKind.TypeParameter)]
        [DataRow("index", CompletionItemKind.TypeParameter)]
        [DataRow("intr", CompletionItemKind.Struct)]
        [DataRow("intrinsic", CompletionItemKind.Struct)]
        [DataRow("inf", CompletionItemKind.Class)]
        [DataRow("inference", CompletionItemKind.Class)]
        [DataRow("loc", CompletionItemKind.Class)]
        [DataRow("localization", CompletionItemKind.Class)]
        [DataRow("prty", CompletionItemKind.Value)]
        [DataRow("property", CompletionItemKind.Value)]
        [DataRow("obj", CompletionItemKind.TypeParameter)]
        [DataRow("object", CompletionItemKind.TypeParameter)]
        [DataRow("opt", CompletionItemKind.Property)]
        [DataRow("optional", CompletionItemKind.Property)]
        [DataRow("pred", CompletionItemKind.TypeParameter)]
        [DataRow("predicate", CompletionItemKind.TypeParameter)]
        [DataRow("pre", CompletionItemKind.Struct)]
        [DataRow("premise", CompletionItemKind.Struct)]
        [DataRow("prf", CompletionItemKind.Class)]
        [DataRow("proof", CompletionItemKind.Class)]
        [DataRow("ret", CompletionItemKind.Property)]
        [DataRow("return", CompletionItemKind.Property)]
        [DataRow("rev", CompletionItemKind.Property)]
        [DataRow("revoke", CompletionItemKind.Property)]
        [DataRow("undef", CompletionItemKind.Constant)]
        [DataRow("undefined", CompletionItemKind.Constant)]
        // keywords without a short form
        [DataRow(literalAlias, CompletionItemKind.Struct)]
        [DataRow(literalAll, CompletionItemKind.Operator)]
        [DataRow(literalAnd, CompletionItemKind.Operator)]
        [DataRow(literalAssL, CompletionItemKind.Property)]
        [DataRow(literalCases, CompletionItemKind.Property)]
        [DataRow(literalEx, CompletionItemKind.Operator)]
        [DataRow(literalExN, CompletionItemKind.Operator)]
        [DataRow(literalFalse, CompletionItemKind.Constant)]
        [DataRow(literalFor, CompletionItemKind.Property)]
        [DataRow("iif", CompletionItemKind.Operator)]
        [DataRow("impl", CompletionItemKind.Operator)]
        [DataRow("in", CompletionItemKind.Property)]
        [DataRow("infix", CompletionItemKind.Operator)]
        [DataRow("is", CompletionItemKind.Interface)]
        [DataRow("not", CompletionItemKind.Operator)]
        [DataRow("or", CompletionItemKind.Operator)]
        [DataRow("postfix", CompletionItemKind.Operator)]
        [DataRow("prefix", CompletionItemKind.Operator)]
        [DataRow("qed", CompletionItemKind.Text)]
        [DataRow("self", CompletionItemKind.Reference)]
        [DataRow("parent", CompletionItemKind.Reference)]
        [DataRow("symbol", CompletionItemKind.TypeParameter)]
        [DataRow("trivial", CompletionItemKind.Text)]
        [DataRow("true", CompletionItemKind.Constant)]
        [DataRow("uses", CompletionItemKind.Module)]
        [DataRow("xor", CompletionItemKind.Operator)]
        public void TestGetDetailCompletionKind(string input, CompletionItemKind expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<CompletionItemKind>(expected, actual.Kind);
        }

        [TestMethod]
        [DataRow(literalAx, "axiom02")]
        [DataRow(literalAxL, "axiom01")]
        [DataRow("post", "postulate02")]
        [DataRow("postulate", "postulate01")]
        [DataRow("thm", "theorem02")]
        [DataRow("theorem", "theorem01")]
        [DataRow("lem", "lemma02")]
        [DataRow("lemma", "lemma01")]
        [DataRow("prop", "proposition02")]
        [DataRow("proposition", "proposition01")]
        [DataRow(literalCor, "corollary02")]
        [DataRow(literalCorL, "corollary01")]
        [DataRow(literalAss, "assume02")]
        [DataRow(literalAssume, "assume01")]
        [DataRow(literalCl, "class02")]
        [DataRow(literalClL, "class01")]
        [DataRow(literalConj, "conjecture02")]
        [DataRow(literalConjL, "conjecture01")]
        [DataRow(literalCon, "conclusion02")]
        [DataRow(literalConL, "conclusion01")]
        [DataRow(literalCtor, "constructor02")]
        [DataRow(literalCtorL, "constructor01")]
        [DataRow(literalDec, "declaration02")]
        [DataRow(literalDecL, "declaration01")]
        [DataRow(literalDef, "definition02")]
        [DataRow(literalDefL, "definition01")]
        [DataRow(literalDel, "delegate02")]
        [DataRow(literalDelL, "delegate01")]
        [DataRow(literalExt, "extension02")]
        [DataRow(literalExtL, "extension01")]
        [DataRow(literalFunc, "function02")]
        [DataRow(literalFuncL, "function01")]
        [DataRow("ind", "index02")]
        [DataRow("index", "index01")]
        [DataRow("intr", "intrinsic02")]
        [DataRow("intrinsic", "intrinsic01")]
        [DataRow("inf", "inference02")]
        [DataRow("inference", "inference01")]
        [DataRow("loc", "localization02")]
        [DataRow("localization", "localization01")]
        [DataRow("prty", "property02")]
        [DataRow("property", "property01")]
        [DataRow("obj", "object02")]
        [DataRow("object", "object01")]
        [DataRow("opt", "optional02")]
        [DataRow("optional", "optional01")]
        [DataRow("pred", "predicate02")]
        [DataRow("predicate", "predicate01")]
        [DataRow("pre", "premise02")]
        [DataRow("premise", "premise01")]
        [DataRow("prf", "proof02")]
        [DataRow("proof", "proof01")]
        [DataRow("ret", "return02")]
        [DataRow("return", "return01")]
        [DataRow("rev", "revoke02")]
        [DataRow("revoke", "revoke01")]
        [DataRow("undef", "undefined02")]
        [DataRow("undefined", "undefined01")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, literalAll)]
        [DataRow(literalAnd, literalAnd)]
        [DataRow(literalAssL, literalAssL)]
        [DataRow(literalCases, literalCases)]
        [DataRow(literalEx, literalEx)]
        [DataRow(literalExN, literalExN)]
        [DataRow(literalFalse, literalFalse)]
        [DataRow(literalFor, literalFor)]
        [DataRow("iif", "iif")]
        [DataRow("impl", "impl")]
        [DataRow("in", "in")]
        [DataRow("infix", "infix")]
        [DataRow("is", "is")]
        [DataRow("not", "not")]
        [DataRow("or", "or")]
        [DataRow("prefix", "prefix")]
        [DataRow("postfix", "postfix")]
        [DataRow("qed", "qed")]
        [DataRow("self", "self")]
        [DataRow("parent", "parent")]
        [DataRow("symbol", "symbol")]
        [DataRow("trivial", "trivial")]
        [DataRow("true", "true")]
        [DataRow("uses", "uses")]
        [DataRow("xor", "xor")]
        public void TestGetCompletionItemSortTextsForKeywords(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Console.WriteLine(input);
            Assert.AreEqual<string>(expected, actual.SortText.Replace("zzz", ""));
        }

        [TestMethod]
        [DataRow(literalAx, "axiom02")]
        [DataRow(literalAxL, "axiom01")]
        [DataRow("post", "postulate02")]
        [DataRow("postulate", "postulate01")]
        [DataRow("thm", "theorem02")]
        [DataRow("theorem", "theorem01")]
        [DataRow("lem", "lemma02")]
        [DataRow("lemma", "lemma01")]
        [DataRow("prop", "proposition02")]
        [DataRow("proposition", "proposition01")]
        [DataRow(literalCor, "corollary02")]
        [DataRow(literalCorL, "corollary01")]
        [DataRow(literalAss, "assume02")]
        [DataRow(literalAssume, "assume01")]
        [DataRow(literalCl, "class02")]
        [DataRow(literalClL, "class01")]
        [DataRow(literalConj, "conjecture02")]
        [DataRow(literalConjL, "conjecture01")]
        [DataRow(literalCon, "conclusion02")]
        [DataRow(literalConL, "conclusion01")]
        [DataRow(literalCtor, "constructor02")]
        [DataRow(literalCtorL, "constructor01")]
        [DataRow(literalDec, "declaration02")]
        [DataRow(literalDecL, "declaration01")]
        [DataRow(literalDef, "definition02")]
        [DataRow(literalDefL, "definition01")]
        [DataRow(literalDel, "delegate02")]
        [DataRow(literalDelL, "delegate01")]
        [DataRow(literalExt, "extension02")]
        [DataRow(literalExtL, "extension01")]
        [DataRow(literalFunc, "function02")]
        [DataRow(literalFuncL, "function01")]
        [DataRow("ind", "index02")]
        [DataRow("index", "index01")]
        [DataRow("intr", "intrinsic02")]
        [DataRow("intrinsic", "intrinsic01")]
        [DataRow("inf", "inference02")]
        [DataRow("inference", "inference01")]
        [DataRow("loc", "localization02")]
        [DataRow("localization", "localization01")]
        [DataRow("prty", "property02")]
        [DataRow("property", "property01")]
        [DataRow("obj", "object02")]
        [DataRow("object", "object01")]
        [DataRow("opt", "optional02")]
        [DataRow("optional", "optional01")]
        [DataRow("pred", "predicate02")]
        [DataRow("predicate", "predicate01")]
        [DataRow("pre", "premise02")]
        [DataRow("premise", "premise01")]
        [DataRow("prf", "proof02")]
        [DataRow("proof", "proof01")]
        [DataRow("ret", "return02")]
        [DataRow("return", "return01")]
        [DataRow("rev", "revoke02")]
        [DataRow("revoke", "revoke01")]
        [DataRow("undef", "undefined02")]
        [DataRow("undefined", "undefined01")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, literalAll)]
        [DataRow(literalAnd, literalAnd)]
        [DataRow(literalAssL, literalAssL)]
        [DataRow(literalCases, literalCases)]
        [DataRow(literalEx, literalEx)]
        [DataRow(literalExN, literalExN)]
        [DataRow(literalFalse, literalFalse)]
        [DataRow(literalFor, literalFor)]
        [DataRow("iif", "iif")]
        [DataRow("impl", "impl")]
        [DataRow("in", "in")]
        [DataRow("infix", "infix")]
        [DataRow("is", "is")]
        [DataRow("not", "not")]
        [DataRow("or", "or")]
        [DataRow("prefix", "prefix")]
        [DataRow("postfix", "postfix")]
        [DataRow("qed", "qed")]
        [DataRow("self", "self")]
        [DataRow("parent", "parent")]
        [DataRow("symbol", "symbol")]
        [DataRow("trivial", "trivial")]
        [DataRow("true", "true")]
        [DataRow("uses", "uses")]
        [DataRow("xor", "xor")]
        public void TestGetCompletionItemSortTextsForSnippets(string input, string expected)
        {
            var actual = new FplCompletionItem(input, "xxx");
            Console.WriteLine(input);
            Assert.AreEqual<string>(expected, actual.SortText);
        }


        [TestMethod]
        [DataRow(literalAx, true)]
        [DataRow(literalAxL, false)]
        [DataRow("post", true)]
        [DataRow("postulate", false)]
        [DataRow("thm", true)]
        [DataRow("theorem", false)]
        [DataRow("lem", true)]
        [DataRow("lemma", false)]
        [DataRow("prop", true)]
        [DataRow("proposition", false)]
        [DataRow(literalCor, true)]
        [DataRow(literalCorL, false)]
        [DataRow(literalAss, true)]
        [DataRow(literalAssume, false)]
        [DataRow(literalCl, true)]
        [DataRow(literalClL, false)]
        [DataRow(literalConj, true)]
        [DataRow(literalConjL, false)]
        [DataRow(literalCon, true)]
        [DataRow(literalConL, false)]
        [DataRow(literalCtor, true)]
        [DataRow(literalCtorL, false)]
        [DataRow(literalDec, true)]
        [DataRow(literalDecL, false)]
        [DataRow(literalDef, true)]
        [DataRow(literalDefL, false)]
        [DataRow(literalDel, true)]
        [DataRow(literalDelL, false)]
        [DataRow(literalExt, true)]
        [DataRow(literalExtL, false)]
        [DataRow(literalFunc, true)]
        [DataRow(literalFuncL, false)]
        [DataRow("ind", true)]
        [DataRow("index", false)]
        [DataRow("intr", true)]
        [DataRow("intrinsic", false)]
        [DataRow("inf", true)]
        [DataRow("inference", false)]
        [DataRow("loc", true)]
        [DataRow("localization", false)]
        [DataRow("prty", true)]
        [DataRow("property", false)]
        [DataRow("obj", true)]
        [DataRow("object", false)]
        [DataRow("opt", true)]
        [DataRow("optional", false)]
        [DataRow("pred", true)]
        [DataRow("predicate", false)]
        [DataRow("pre", true)]
        [DataRow("premise", false)]
        [DataRow("prf", true)]
        [DataRow("proof", false)]
        [DataRow("ret", true)]
        [DataRow("return", false)]
        [DataRow("rev", true)]
        [DataRow("revoke", false)]
        [DataRow("undef", true)]
        [DataRow("undefined", false)]
        // keywords without a short form
        [DataRow(literalAlias, false)]
        [DataRow(literalAll, false)]
        [DataRow(literalAnd, false)]
        [DataRow(literalAssL, false)]
        [DataRow(literalCases, false)]
        [DataRow(literalEx, false)]
        [DataRow(literalExN, false)]
        [DataRow(literalFalse, false)]
        [DataRow(literalFor, false)]
        [DataRow("iif", false)]
        [DataRow("impl", false)]
        [DataRow("in", false)]
        [DataRow("infix", false)]
        [DataRow("is", false)]
        [DataRow("not", false)]
        [DataRow("or", false)]
        [DataRow("prefix", false)]
        [DataRow("postfix", false)]
        [DataRow("qed", false)]
        [DataRow("self", false)]
        [DataRow("parent", false)]
        [DataRow("symbol", false)]
        [DataRow("trivial", false)]
        [DataRow("true", false)]
        [DataRow("uses", false)]
        [DataRow("xor", false)]
        public void TestGetDetailIsShort(string input, bool expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<bool>(expected, actual.IsShort);
        }
    }
}
