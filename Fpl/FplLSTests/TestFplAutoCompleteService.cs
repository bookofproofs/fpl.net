// Ignore Spelling: Fpl

using OmniSharp.Extensions.LanguageServer.Protocol.Models;
using FplLS;
using static FplGrammarTypes.Ast;
using static FplGrammarCommons;

namespace FplLSTests
{
    [TestClass]
    public class TestFplCompletionItem
    {
        [TestMethod]
        [DataRow("<some token>", "some token")]
        [DataRow("'token'", "token")]
        [DataRow("some token", "some token")]
        [DataRow("token", "token")]
        [DataRow("'token", "'token")]
        [DataRow("token'", "token'")]
        [DataRow("<token", "<token")]
        [DataRow("token>", "token>")]
        public void TestGetCompletionItemStrippingBracketsAndQuotes(string input, string expected)
        {
            var actual = FplCompletionItem.StripQuotesOrBrackets(input);
            Assert.AreEqual<string>(expected, actual);
        }

        [TestMethod]
        [DataRow(literalAx)]
        [DataRow(literalAxL)]
        [DataRow(literalPost)]
        [DataRow(literalPostL)]
        [DataRow("thm")]
        [DataRow("theorem")]
        [DataRow(literalLem)]
        [DataRow(literalLemL)]
        [DataRow(literalProp)]
        [DataRow(literalPropL)]
        [DataRow(literalCor)]
        [DataRow(literalCorL)]
        [DataRow(literalAss)]
        [DataRow(literalAssume)]
        [DataRow(literalCl)]
        [DataRow(literalClL)]
        [DataRow(literalConj)]
        [DataRow(literalConjL)]
        [DataRow(literalCon)]
        [DataRow(literalConL)]
        [DataRow(literalCtor)]
        [DataRow(literalCtorL)]
        [DataRow(literalDec)]
        [DataRow(literalDecL)]
        [DataRow(literalDef)]
        [DataRow(literalDefL)]
        [DataRow(literalDel)]
        [DataRow(literalDelL)]
        [DataRow(literalExt)]
        [DataRow(literalExtL)]
        [DataRow(literalFunc)]
        [DataRow(literalFuncL)]
        [DataRow(literalInd)]
        [DataRow(literalIndL)]
        [DataRow(literalInfix)]
        [DataRow(literalIntr)]
        [DataRow(literalIntrL)]
        [DataRow(literalInf)]
        [DataRow(literalInfL)]
        [DataRow(literalLoc)]
        [DataRow(literalLocL)]
        [DataRow("mand")]
        [DataRow("mandatory")]
        [DataRow(literalObj)]
        [DataRow(literalObjL)]
        [DataRow(literalOpt)]
        [DataRow(literalOptL)]
        [DataRow(literalPostFix)]
        [DataRow(literalPred)]
        [DataRow(literalPredL)]
        [DataRow(literalPre)]
        [DataRow(literalPrefix)]
        [DataRow(literalPreL)]
        [DataRow(literalPrf)]
        [DataRow(literalPrfL)]
        [DataRow("ret")]
        [DataRow("return")]
        [DataRow("rev")]
        [DataRow("revoke")]
        [DataRow("symbol")]
        [DataRow("undef")]
        [DataRow("undefined")]
        public void TestGetCompletionItemLabels(string input)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>("_ " + input, actual.Label);
        }

        [TestMethod]
        [DataRow(literalAx, "axiom (short form)")]
        [DataRow(literalPost, "postulate (short form)")]
        [DataRow("thm", "theorem (short form)")]
        [DataRow(literalLem, "lemma (short form)")]
        [DataRow(literalProp, "proposition (short form)")]
        [DataRow(literalCor, "corollary (short form)")]
        [DataRow(literalAss, "argument (assume, short form)")]
        [DataRow(literalCl, "class (short form)")]
        [DataRow(literalConj, "conjecture (short form)")]
        [DataRow(literalCon, "conclusion (short form)")]
        [DataRow(literalCtor, "constructor (short form)")]
        [DataRow(literalDec, "declaration (short form)")]
        [DataRow(literalDef, "definition (short form)")]
        [DataRow(literalDel, "delegate (short form)")]
        [DataRow(literalFunc, "type (functional term, short form)")]
        [DataRow(literalInd, "type (index, short form)")]
        [DataRow(literalIntr, "intrinsic (short form)")]
        [DataRow(literalInf, "rule of inference (short form)")]
        [DataRow(literalLoc, "localization (short form)")]
        [DataRow(literalPrty, "property (short form)")]
        [DataRow(literalObj, "type (object, short form)")]
        [DataRow(literalOpt, "optional (short form)")]
        [DataRow(literalPred, "type (predicate, short form)")]
        [DataRow(literalPre, "premise (short form)")]
        [DataRow(literalPrf, "proof (short form)")]
        [DataRow("ret", "statement (return, short form)")]
        [DataRow("rev", "argument (revoke, short form)")]
        [DataRow("undef", "undefined (short form)")]
        public void TestGetDetailShortForms(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>(expected, actual.Detail);
        }

        [TestMethod]
        [DataRow(literalAxL, literalAxL)]
        [DataRow(literalPostL, literalPostL)]
        [DataRow("theorem", "theorem")]
        [DataRow(literalLemL, literalLemL)]
        [DataRow(literalPropL, literalPropL)]
        [DataRow(literalCorL, literalCorL)]
        [DataRow(literalAssume, "argument (assume)")]
        [DataRow(literalClL, literalClL)]
        [DataRow(literalConjL, literalConjL)]
        [DataRow(literalConL, literalConL)]
        [DataRow(literalCtorL, literalCtorL)]
        [DataRow(literalDecL, literalDecL)]
        [DataRow(literalDefL, literalDefL)]
        [DataRow(literalDelL, literalDelL)]
        [DataRow(literalExtL, literalExtL)]
        [DataRow(literalFuncL, "type (functional term)")]
        [DataRow(literalIndL, "type (index)")]
        [DataRow(literalIntrL, literalIntrL)]
        [DataRow(literalInfL, "rule of inference")]
        [DataRow(literalLocL, literalLocL)]
        [DataRow(literalPrtyL, literalPrtyL)]
        [DataRow(literalObjL, "type (object)")]
        [DataRow(literalOptL, literalOptL)]
        [DataRow(literalPredL, "type (predicate)")]
        [DataRow(literalPreL, literalPreL)]
        [DataRow(literalPrfL, literalPrfL)]
        [DataRow("return", "statement (return)")]
        [DataRow("revoke", "argument (revoke)")]
        [DataRow("undefined", "undefined")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, "predicate (all quantor)")]
        [DataRow(literalAnd, "predicate (conjunction)")]
        [DataRow(literalAssL, "statement (assert)")]
        [DataRow(literalCases, "statement (cases)")]
        [DataRow(literalEx, "predicate (exists quantor)")]
        [DataRow(literalExN, "predicate (exists n-times quantor)")]
        [DataRow(literalFalse, "predicate (false)")]
        [DataRow(literalFor, "statement (for loop)")]
        [DataRow(literalIif, "predicate (equivalence, <=>)")]
        [DataRow(literalImpl, "predicate (implication, =>)")]
        [DataRow(literalIn, "clause (in type or in range)")]
        [DataRow(literalInfix, "infix operator")]
        [DataRow(literalIs, "predicate (is of type)")]
        [DataRow(literalNot, "predicate (negation)")]
        [DataRow(literalOr, "predicate (disjunction)")]
        [DataRow(literalPrefix, "prefix operator")]
        [DataRow(literalPostFix, "postfix operator")]
        [DataRow("qed", "(quod erat demonstrandum)")]
        [DataRow("self", "reference (to self)")]
        [DataRow(literalParent, "reference (to parent)")]
        [DataRow("symbol", "object symbol")]
        [DataRow("trivial", "argument (trivial)")]
        [DataRow("true", "predicate (true)")]
        [DataRow("uses", "clause (uses)")]
        [DataRow("xor", "predicate (exclusive or)")]
        public void TestGetDetailLongForms(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>(expected, actual.Detail);
        }


        [TestMethod]
        [DataRow(literalAx, CompletionItemKind.Class)]
        [DataRow(literalAxL, CompletionItemKind.Class)]
        [DataRow(literalPost, CompletionItemKind.Class)]
        [DataRow(literalPostL, CompletionItemKind.Class)]
        [DataRow("thm", CompletionItemKind.Class)]
        [DataRow("theorem", CompletionItemKind.Class)]
        [DataRow(literalLem, CompletionItemKind.Class)]
        [DataRow(literalLemL, CompletionItemKind.Class)]
        [DataRow(literalProp, CompletionItemKind.Class)]
        [DataRow(literalPropL, CompletionItemKind.Class)]
        [DataRow(literalCor, CompletionItemKind.Class)]
        [DataRow(literalCorL, CompletionItemKind.Class)]
        [DataRow(literalAss, CompletionItemKind.Property)]
        [DataRow(literalAssume, CompletionItemKind.Property)]
        [DataRow(literalCl, CompletionItemKind.TypeParameter)]
        [DataRow(literalClL, CompletionItemKind.TypeParameter)]
        [DataRow(literalConj, CompletionItemKind.Class)]
        [DataRow(literalConjL, CompletionItemKind.Class)]
        [DataRow(literalCon, CompletionItemKind.Struct)]
        [DataRow(literalConL, CompletionItemKind.Struct)]
        [DataRow(literalCtor, CompletionItemKind.Constructor)]
        [DataRow(literalCtorL, CompletionItemKind.Constructor)]
        [DataRow(literalDec, CompletionItemKind.Property)]
        [DataRow(literalDecL, CompletionItemKind.Property)]
        [DataRow(literalDef, CompletionItemKind.Class)]
        [DataRow(literalDefL, CompletionItemKind.Class)]
        [DataRow(literalDel, CompletionItemKind.Event)]
        [DataRow(literalDelL, CompletionItemKind.Event)]
        [DataRow(literalExt, CompletionItemKind.Class)]
        [DataRow(literalExtL, CompletionItemKind.Class)]
        [DataRow(literalFunc, CompletionItemKind.TypeParameter)]
        [DataRow(literalFuncL, CompletionItemKind.TypeParameter)]
        [DataRow(literalInd, CompletionItemKind.TypeParameter)]
        [DataRow(literalIndL, CompletionItemKind.TypeParameter)]
        [DataRow(literalIntr, CompletionItemKind.Struct)]
        [DataRow(literalIntrL, CompletionItemKind.Struct)]
        [DataRow(literalInf, CompletionItemKind.Class)]
        [DataRow(literalInfL, CompletionItemKind.Class)]
        [DataRow(literalLoc, CompletionItemKind.Class)]
        [DataRow(literalLocL, CompletionItemKind.Class)]
        [DataRow(literalPrty, CompletionItemKind.Value)]
        [DataRow(literalPrtyL, CompletionItemKind.Value)]
        [DataRow(literalObj, CompletionItemKind.TypeParameter)]
        [DataRow(literalObjL, CompletionItemKind.TypeParameter)]
        [DataRow(literalOpt, CompletionItemKind.Property)]
        [DataRow(literalOptL, CompletionItemKind.Property)]
        [DataRow(literalPred, CompletionItemKind.TypeParameter)]
        [DataRow(literalPredL, CompletionItemKind.TypeParameter)]
        [DataRow(literalPre, CompletionItemKind.Struct)]
        [DataRow(literalPreL, CompletionItemKind.Struct)]
        [DataRow(literalPrf, CompletionItemKind.Class)]
        [DataRow(literalPrfL, CompletionItemKind.Class)]
        [DataRow("ret", CompletionItemKind.Property)]
        [DataRow("return", CompletionItemKind.Property)]
        [DataRow("rev", CompletionItemKind.Property)]
        [DataRow("revoke", CompletionItemKind.Property)]
        [DataRow("undef", CompletionItemKind.Constant)]
        [DataRow("undefined", CompletionItemKind.Constant)]
        // keywords without a short form
        [DataRow(literalAlias, CompletionItemKind.Struct)]
        [DataRow(literalAll, CompletionItemKind.Operator)]
        [DataRow(literalAnd, CompletionItemKind.Operator)]
        [DataRow(literalAssL, CompletionItemKind.Property)]
        [DataRow(literalCases, CompletionItemKind.Property)]
        [DataRow(literalEx, CompletionItemKind.Operator)]
        [DataRow(literalExN, CompletionItemKind.Operator)]
        [DataRow(literalFalse, CompletionItemKind.Constant)]
        [DataRow(literalFor, CompletionItemKind.Property)]
        [DataRow(literalIif, CompletionItemKind.Operator)]
        [DataRow(literalImpl, CompletionItemKind.Operator)]
        [DataRow(literalIn, CompletionItemKind.Property)]
        [DataRow(literalInfix, CompletionItemKind.Operator)]
        [DataRow(literalIs, CompletionItemKind.Interface)]
        [DataRow(literalNot, CompletionItemKind.Operator)]
        [DataRow(literalOr, CompletionItemKind.Operator)]
        [DataRow(literalPostFix, CompletionItemKind.Operator)]
        [DataRow(literalPrefix, CompletionItemKind.Operator)]
        [DataRow("qed", CompletionItemKind.Text)]
        [DataRow("self", CompletionItemKind.Reference)]
        [DataRow(literalParent, CompletionItemKind.Reference)]
        [DataRow("symbol", CompletionItemKind.TypeParameter)]
        [DataRow("trivial", CompletionItemKind.Text)]
        [DataRow("true", CompletionItemKind.Constant)]
        [DataRow("uses", CompletionItemKind.Module)]
        [DataRow("xor", CompletionItemKind.Operator)]
        public void TestGetDetailCompletionKind(string input, CompletionItemKind expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<CompletionItemKind>(expected, actual.Kind);
        }

        [TestMethod]
        [DataRow(literalAx, "axiom02")]
        [DataRow(literalAxL, "axiom01")]
        [DataRow(literalPost, "postulate02")]
        [DataRow(literalPostL, "postulate01")]
        [DataRow("thm", "theorem02")]
        [DataRow("theorem", "theorem01")]
        [DataRow(literalLem, "lemma02")]
        [DataRow(literalLemL, "lemma01")]
        [DataRow(literalProp, "proposition02")]
        [DataRow(literalPropL, "proposition01")]
        [DataRow(literalCor, "corollary02")]
        [DataRow(literalCorL, "corollary01")]
        [DataRow(literalAss, "assume02")]
        [DataRow(literalAssume, "assume01")]
        [DataRow(literalCl, "class02")]
        [DataRow(literalClL, "class01")]
        [DataRow(literalConj, "conjecture02")]
        [DataRow(literalConjL, "conjecture01")]
        [DataRow(literalCon, "conclusion02")]
        [DataRow(literalConL, "conclusion01")]
        [DataRow(literalCtor, "constructor02")]
        [DataRow(literalCtorL, "constructor01")]
        [DataRow(literalDec, "declaration02")]
        [DataRow(literalDecL, "declaration01")]
        [DataRow(literalDef, "definition02")]
        [DataRow(literalDefL, "definition01")]
        [DataRow(literalDel, "delegate02")]
        [DataRow(literalDelL, "delegate01")]
        [DataRow(literalExt, "extension02")]
        [DataRow(literalExtL, "extension01")]
        [DataRow(literalFunc, "function02")]
        [DataRow(literalFuncL, "function01")]
        [DataRow(literalInd, "index02")]
        [DataRow(literalIndL, "index01")]
        [DataRow(literalIntr, "intrinsic02")]
        [DataRow(literalIntrL, "intrinsic01")]
        [DataRow(literalInf, "inference02")]
        [DataRow(literalInfL, "inference01")]
        [DataRow(literalLoc, "localization02")]
        [DataRow(literalLocL, "localization01")]
        [DataRow(literalPrty, "property02")]
        [DataRow(literalPrtyL, "property01")]
        [DataRow(literalObj, "object02")]
        [DataRow(literalObjL, "object01")]
        [DataRow(literalOpt, "optional02")]
        [DataRow(literalOptL, "optional01")]
        [DataRow(literalPred, "predicate02")]
        [DataRow(literalPredL, "predicate01")]
        [DataRow(literalPre, "premise02")]
        [DataRow(literalPreL, "premise01")]
        [DataRow(literalPrf, "proof02")]
        [DataRow(literalPrfL, "proof01")]
        [DataRow("ret", "return02")]
        [DataRow("return", "return01")]
        [DataRow("rev", "revoke02")]
        [DataRow("revoke", "revoke01")]
        [DataRow("undef", "undefined02")]
        [DataRow("undefined", "undefined01")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, literalAll)]
        [DataRow(literalAnd, literalAnd)]
        [DataRow(literalAssL, literalAssL)]
        [DataRow(literalCases, literalCases)]
        [DataRow(literalEx, literalEx)]
        [DataRow(literalExN, literalExN)]
        [DataRow(literalFalse, literalFalse)]
        [DataRow(literalFor, literalFor)]
        [DataRow(literalIif, literalIif)]
        [DataRow(literalImpl, literalImpl)]
        [DataRow(literalIn, literalIn)]
        [DataRow(literalInfix, literalInfix)]
        [DataRow(literalIs, literalIs)]
        [DataRow(literalNot, literalNot)]
        [DataRow(literalOr, literalOr)]
        [DataRow(literalPrefix, literalPrefix)]
        [DataRow(literalPostFix, literalPostFix)]
        [DataRow("qed", "qed")]
        [DataRow("self", "self")]
        [DataRow(literalParent, literalParent)]
        [DataRow("symbol", "symbol")]
        [DataRow("trivial", "trivial")]
        [DataRow("true", "true")]
        [DataRow("uses", "uses")]
        [DataRow("xor", "xor")]
        public void TestGetCompletionItemSortTextsForKeywords(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Console.WriteLine(input);
            Assert.AreEqual<string>(expected, actual.SortText.Replace("zzz", ""));
        }

        [TestMethod]
        [DataRow(literalAx, "axiom02")]
        [DataRow(literalAxL, "axiom01")]
        [DataRow(literalPost, "postulate02")]
        [DataRow(literalPostL, "postulate01")]
        [DataRow("thm", "theorem02")]
        [DataRow("theorem", "theorem01")]
        [DataRow(literalLem, "lemma02")]
        [DataRow(literalLemL, "lemma01")]
        [DataRow(literalProp, "proposition02")]
        [DataRow(literalPropL, "proposition01")]
        [DataRow(literalCor, "corollary02")]
        [DataRow(literalCorL, "corollary01")]
        [DataRow(literalAss, "assume02")]
        [DataRow(literalAssume, "assume01")]
        [DataRow(literalCl, "class02")]
        [DataRow(literalClL, "class01")]
        [DataRow(literalConj, "conjecture02")]
        [DataRow(literalConjL, "conjecture01")]
        [DataRow(literalCon, "conclusion02")]
        [DataRow(literalConL, "conclusion01")]
        [DataRow(literalCtor, "constructor02")]
        [DataRow(literalCtorL, "constructor01")]
        [DataRow(literalDec, "declaration02")]
        [DataRow(literalDecL, "declaration01")]
        [DataRow(literalDef, "definition02")]
        [DataRow(literalDefL, "definition01")]
        [DataRow(literalDel, "delegate02")]
        [DataRow(literalDelL, "delegate01")]
        [DataRow(literalExt, "extension02")]
        [DataRow(literalExtL, "extension01")]
        [DataRow(literalFunc, "function02")]
        [DataRow(literalFuncL, "function01")]
        [DataRow(literalInd, "index02")]
        [DataRow(literalIndL, "index01")]
        [DataRow(literalIntr, "intrinsic02")]
        [DataRow(literalIntrL, "intrinsic01")]
        [DataRow(literalInf, "inference02")]
        [DataRow(literalInfL, "inference01")]
        [DataRow(literalLoc, "localization02")]
        [DataRow(literalLocL, "localization01")]
        [DataRow(literalPrty, "property02")]
        [DataRow(literalPrtyL, "property01")]
        [DataRow(literalObj, "object02")]
        [DataRow(literalObjL, "object01")]
        [DataRow(literalOpt, "optional02")]
        [DataRow(literalOptL, "optional01")]
        [DataRow(literalPred, "predicate02")]
        [DataRow(literalPredL, "predicate01")]
        [DataRow(literalPre, "premise02")]
        [DataRow(literalPreL, "premise01")]
        [DataRow(literalPrf, "proof02")]
        [DataRow(literalPrfL, "proof01")]
        [DataRow("ret", "return02")]
        [DataRow("return", "return01")]
        [DataRow("rev", "revoke02")]
        [DataRow("revoke", "revoke01")]
        [DataRow("undef", "undefined02")]
        [DataRow("undefined", "undefined01")]
        // keywords without a short form
        [DataRow(literalAlias, literalAlias)]
        [DataRow(literalAll, literalAll)]
        [DataRow(literalAnd, literalAnd)]
        [DataRow(literalAssL, literalAssL)]
        [DataRow(literalCases, literalCases)]
        [DataRow(literalEx, literalEx)]
        [DataRow(literalExN, literalExN)]
        [DataRow(literalFalse, literalFalse)]
        [DataRow(literalFor, literalFor)]
        [DataRow(literalIif, literalIif)]
        [DataRow(literalImpl, literalImpl)]
        [DataRow(literalIn, literalIn)]
        [DataRow(literalInfix, literalInfix)]
        [DataRow(literalIs, literalIs)]
        [DataRow(literalNot, literalNot)]
        [DataRow(literalOr, literalOr)]
        [DataRow(literalPrefix, literalPrefix)]
        [DataRow(literalPostFix, literalPostFix)]
        [DataRow("qed", "qed")]
        [DataRow("self", "self")]
        [DataRow(literalParent, literalParent)]
        [DataRow("symbol", "symbol")]
        [DataRow("trivial", "trivial")]
        [DataRow("true", "true")]
        [DataRow("uses", "uses")]
        [DataRow("xor", "xor")]
        public void TestGetCompletionItemSortTextsForSnippets(string input, string expected)
        {
            var actual = new FplCompletionItem(input, "xxx");
            Console.WriteLine(input);
            Assert.AreEqual<string>(expected, actual.SortText);
        }


        [TestMethod]
        [DataRow(literalAx, true)]
        [DataRow(literalAxL, false)]
        [DataRow(literalPost, true)]
        [DataRow(literalPostL, false)]
        [DataRow("thm", true)]
        [DataRow("theorem", false)]
        [DataRow(literalLem, true)]
        [DataRow(literalLemL, false)]
        [DataRow(literalProp, true)]
        [DataRow(literalPropL, false)]
        [DataRow(literalCor, true)]
        [DataRow(literalCorL, false)]
        [DataRow(literalAss, true)]
        [DataRow(literalAssume, false)]
        [DataRow(literalCl, true)]
        [DataRow(literalClL, false)]
        [DataRow(literalConj, true)]
        [DataRow(literalConjL, false)]
        [DataRow(literalCon, true)]
        [DataRow(literalConL, false)]
        [DataRow(literalCtor, true)]
        [DataRow(literalCtorL, false)]
        [DataRow(literalDec, true)]
        [DataRow(literalDecL, false)]
        [DataRow(literalDef, true)]
        [DataRow(literalDefL, false)]
        [DataRow(literalDel, true)]
        [DataRow(literalDelL, false)]
        [DataRow(literalExt, true)]
        [DataRow(literalExtL, false)]
        [DataRow(literalFunc, true)]
        [DataRow(literalFuncL, false)]
        [DataRow(literalInd, true)]
        [DataRow(literalIndL, false)]
        [DataRow(literalIntr, true)]
        [DataRow(literalIntrL, false)]
        [DataRow(literalInf, true)]
        [DataRow(literalInfL, false)]
        [DataRow(literalLoc, true)]
        [DataRow(literalLocL, false)]
        [DataRow(literalPrty, true)]
        [DataRow(literalPrtyL, false)]
        [DataRow(literalObj, true)]
        [DataRow(literalObjL, false)]
        [DataRow(literalOpt, true)]
        [DataRow(literalOptL, false)]
        [DataRow(literalPred, true)]
        [DataRow(literalPredL, false)]
        [DataRow(literalPre, true)]
        [DataRow(literalPreL, false)]
        [DataRow(literalPrf, true)]
        [DataRow(literalPrfL, false)]
        [DataRow("ret", true)]
        [DataRow("return", false)]
        [DataRow("rev", true)]
        [DataRow("revoke", false)]
        [DataRow("undef", true)]
        [DataRow("undefined", false)]
        // keywords without a short form
        [DataRow(literalAlias, false)]
        [DataRow(literalAll, false)]
        [DataRow(literalAnd, false)]
        [DataRow(literalAssL, false)]
        [DataRow(literalCases, false)]
        [DataRow(literalEx, false)]
        [DataRow(literalExN, false)]
        [DataRow(literalFalse, false)]
        [DataRow(literalFor, false)]
        [DataRow(literalIif, false)]
        [DataRow(literalImpl, false)]
        [DataRow(literalIn, false)]
        [DataRow(literalInfix, false)]
        [DataRow(literalIs, false)]
        [DataRow(literalNot, false)]
        [DataRow(literalOr, false)]
        [DataRow(literalPrefix, false)]
        [DataRow(literalPostFix, false)]
        [DataRow("qed", false)]
        [DataRow("self", false)]
        [DataRow(literalParent, false)]
        [DataRow("symbol", false)]
        [DataRow("trivial", false)]
        [DataRow("true", false)]
        [DataRow("uses", false)]
        [DataRow("xor", false)]
        public void TestGetDetailIsShort(string input, bool expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<bool>(expected, actual.IsShort);
        }
    }
}
