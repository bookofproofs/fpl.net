// Ignore Spelling: Fpl

using OmniSharp.Extensions.LanguageServer.Protocol.Models;
using FplLS;
using static FplGrammarTypes.Ast;
using static FplPrimitives;

namespace FplLSTests
{
    [TestClass]
    public class TestFplCompletionItem
    {
        [TestMethod]
        [DataRow("<some token>", "some token")]
        [DataRow("'token'", "token")]
        [DataRow("some token", "some token")]
        [DataRow("token", "token")]
        [DataRow("'token", "'token")]
        [DataRow("token'", "token'")]
        [DataRow("<token", "<token")]
        [DataRow("token>", "token>")]
        public void TestGetCompletionItemStrippingBracketsAndQuotes(string input, string expected)
        {
            var actual = FplCompletionItem.StripQuotesOrBrackets(input);
            Assert.AreEqual<string>(expected, actual);
        }

        [TestMethod]
        [DataRow(LiteralAx)]
        [DataRow(LiteralAxL)]
        [DataRow(LiteralPost)]
        [DataRow(LiteralPostL)]
        [DataRow(LiteralThm)]
        [DataRow(LiteralThmL)]
        [DataRow(LiteralLem)]
        [DataRow(LiteralLemL)]
        [DataRow(LiteralProp)]
        [DataRow(LiteralPropL)]
        [DataRow(LiteralCor)]
        [DataRow(LiteralCorL)]
        [DataRow(LiteralAss)]
        [DataRow(LiteralAssume)]
        [DataRow(LiteralCl)]
        [DataRow(LiteralClL)]
        [DataRow(LiteralConj)]
        [DataRow(LiteralConjL)]
        [DataRow(LiteralCon)]
        [DataRow(LiteralConL)]
        [DataRow(LiteralCtor)]
        [DataRow(LiteralCtorL)]
        [DataRow(LiteralDec)]
        [DataRow(LiteralDecL)]
        [DataRow(LiteralDef)]
        [DataRow(LiteralDefL)]
        [DataRow(LiteralDel)]
        [DataRow(LiteralDelL)]
        [DataRow(LiteralExt)]
        [DataRow(LiteralExtL)]
        [DataRow(LiteralFunc)]
        [DataRow(LiteralFuncL)]
        [DataRow(LiteralInd)]
        [DataRow(LiteralIndL)]
        [DataRow(LiteralInfix)]
        [DataRow(LiteralIntr)]
        [DataRow(LiteralIntrL)]
        [DataRow(LiteralInf)]
        [DataRow(LiteralInfL)]
        [DataRow(LiteralLoc)]
        [DataRow(LiteralLocL)]
        [DataRow("mand")]
        [DataRow("mandatory")]
        [DataRow(LiteralObj)]
        [DataRow(LiteralObjL)]
        [DataRow(LiteralOpt)]
        [DataRow(LiteralOptL)]
        [DataRow(LiteralPostFix)]
        [DataRow(LiteralPred)]
        [DataRow(LiteralPredL)]
        [DataRow(LiteralPre)]
        [DataRow(LiteralPrefix)]
        [DataRow(LiteralPreL)]
        [DataRow(LiteralPrf)]
        [DataRow(LiteralPrfL)]
        [DataRow(LiteralRet)]
        [DataRow(LiteralRetL)]
        [DataRow(LiteralRev)]
        [DataRow(LiteralRevL)]
        [DataRow(LiteralSymbol)]
        [DataRow(LiteralUndef)]
        [DataRow(LiteralUndefL)]
        public void TestGetCompletionItemLabels(string input)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>("_ " + input, actual.Label);
        }

        [TestMethod]
        [DataRow(LiteralAx, "axiom (short form)")]
        [DataRow(LiteralPost, "postulate (short form)")]
        [DataRow(LiteralThm, "theorem (short form)")]
        [DataRow(LiteralLem, "lemma (short form)")]
        [DataRow(LiteralProp, "proposition (short form)")]
        [DataRow(LiteralCor, "corollary (short form)")]
        [DataRow(LiteralAss, "argument (assume, short form)")]
        [DataRow(LiteralCl, "class (short form)")]
        [DataRow(LiteralConj, "conjecture (short form)")]
        [DataRow(LiteralCon, "conclusion (short form)")]
        [DataRow(LiteralCtor, "constructor (short form)")]
        [DataRow(LiteralDec, "declaration (short form)")]
        [DataRow(LiteralDef, "definition (short form)")]
        [DataRow(LiteralDel, "delegate (short form)")]
        [DataRow(LiteralFunc, "type (functional term, short form)")]
        [DataRow(LiteralInd, "type (index, short form)")]
        [DataRow(LiteralIntr, "intrinsic (short form)")]
        [DataRow(LiteralInf, "rule of inference (short form)")]
        [DataRow(LiteralLoc, "localization (short form)")]
        [DataRow(LiteralPrty, "property (short form)")]
        [DataRow(LiteralObj, "type (object, short form)")]
        [DataRow(LiteralOpt, "optional (short form)")]
        [DataRow(LiteralPred, "type (predicate, short form)")]
        [DataRow(LiteralPre, "premise (short form)")]
        [DataRow(LiteralPrf, "proof (short form)")]
        [DataRow(LiteralRet, "statement (return, short form)")]
        [DataRow(LiteralRev, "argument (revoke, short form)")]
        [DataRow(LiteralUndef, "undefined (short form)")]
        public void TestGetDetailShortForms(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>(expected, actual.Detail);
        }

        [TestMethod]
        [DataRow(LiteralAxL, LiteralAxL)]
        [DataRow(LiteralPostL, LiteralPostL)]
        [DataRow(LiteralThmL, LiteralThmL)]
        [DataRow(LiteralLemL, LiteralLemL)]
        [DataRow(LiteralPropL, LiteralPropL)]
        [DataRow(LiteralCorL, LiteralCorL)]
        [DataRow(LiteralAssume, "argument (assume)")]
        [DataRow(LiteralClL, LiteralClL)]
        [DataRow(LiteralConjL, LiteralConjL)]
        [DataRow(LiteralConL, LiteralConL)]
        [DataRow(LiteralCtorL, LiteralCtorL)]
        [DataRow(LiteralDecL, LiteralDecL)]
        [DataRow(LiteralDefL, LiteralDefL)]
        [DataRow(LiteralDelL, LiteralDelL)]
        [DataRow(LiteralExtL, LiteralExtL)]
        [DataRow(LiteralFuncL, "type (functional term)")]
        [DataRow(LiteralIndL, "type (index)")]
        [DataRow(LiteralIntrL, LiteralIntrL)]
        [DataRow(LiteralInfL, "rule of inference")]
        [DataRow(LiteralLocL, LiteralLocL)]
        [DataRow(LiteralPrtyL, LiteralPrtyL)]
        [DataRow(LiteralObjL, "type (object)")]
        [DataRow(LiteralOptL, LiteralOptL)]
        [DataRow(LiteralPredL, "type (predicate)")]
        [DataRow(LiteralPreL, LiteralPreL)]
        [DataRow(LiteralPrfL, LiteralPrfL)]
        [DataRow(LiteralRetL, "statement (return)")]
        [DataRow(LiteralRevL, "argument (revoke)")]
        [DataRow(LiteralUndefL, LiteralUndefL)]
        // keywords without a short form
        [DataRow(LiteralAlias, LiteralAlias)]
        [DataRow(LiteralAll, "predicate (all quantor)")]
        [DataRow(LiteralAnd, "predicate (conjunction)")]
        [DataRow(LiteralAssL, "statement (assert)")]
        [DataRow(LiteralCases, "statement (cases)")]
        [DataRow(LiteralEx, "predicate (exists quantor)")]
        [DataRow(LiteralExN, "predicate (exists n-times quantor)")]
        [DataRow(LiteralFalse, "predicate (false)")]
        [DataRow(LiteralFor, "statement (for loop)")]
        [DataRow(LiteralIif, "predicate (equivalence, <=>)")]
        [DataRow(LiteralImpl, "predicate (implication, =>)")]
        [DataRow(LiteralIn, "clause (in type or in range)")]
        [DataRow(LiteralInfix, "infix operator")]
        [DataRow(LiteralIs, "predicate (is of type)")]
        [DataRow(LiteralNot, "predicate (negation)")]
        [DataRow(LiteralOr, "predicate (disjunction)")]
        [DataRow(LiteralPrefix, "prefix operator")]
        [DataRow(LiteralPostFix, "postfix operator")]
        [DataRow(LiteralQed, "(quod erat demonstrandum)")]
        [DataRow(LiteralSelf, "reference (to self)")]
        [DataRow(LiteralParent, "reference (to parent)")]
        [DataRow(LiteralSymbol, "object symbol")]
        [DataRow(LiteralTrivial, "argument (trivial)")]
        [DataRow(LiteralTrue, "predicate (true)")]
        [DataRow(LiteralUses, "clause (uses)")]
        [DataRow(LiteralXor, "predicate (exclusive or)")]
        public void TestGetDetailLongForms(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<string>(expected, actual.Detail);
        }


        [TestMethod]
        [DataRow(LiteralAx, CompletionItemKind.Class)]
        [DataRow(LiteralAxL, CompletionItemKind.Class)]
        [DataRow(LiteralPost, CompletionItemKind.Class)]
        [DataRow(LiteralPostL, CompletionItemKind.Class)]
        [DataRow(LiteralThm, CompletionItemKind.Class)]
        [DataRow(LiteralThmL, CompletionItemKind.Class)]
        [DataRow(LiteralLem, CompletionItemKind.Class)]
        [DataRow(LiteralLemL, CompletionItemKind.Class)]
        [DataRow(LiteralProp, CompletionItemKind.Class)]
        [DataRow(LiteralPropL, CompletionItemKind.Class)]
        [DataRow(LiteralCor, CompletionItemKind.Class)]
        [DataRow(LiteralCorL, CompletionItemKind.Class)]
        [DataRow(LiteralAss, CompletionItemKind.Property)]
        [DataRow(LiteralAssume, CompletionItemKind.Property)]
        [DataRow(LiteralCl, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralClL, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralConj, CompletionItemKind.Class)]
        [DataRow(LiteralConjL, CompletionItemKind.Class)]
        [DataRow(LiteralCon, CompletionItemKind.Struct)]
        [DataRow(LiteralConL, CompletionItemKind.Struct)]
        [DataRow(LiteralCtor, CompletionItemKind.Constructor)]
        [DataRow(LiteralCtorL, CompletionItemKind.Constructor)]
        [DataRow(LiteralDec, CompletionItemKind.Property)]
        [DataRow(LiteralDecL, CompletionItemKind.Property)]
        [DataRow(LiteralDef, CompletionItemKind.Class)]
        [DataRow(LiteralDefL, CompletionItemKind.Class)]
        [DataRow(LiteralDel, CompletionItemKind.Event)]
        [DataRow(LiteralDelL, CompletionItemKind.Event)]
        [DataRow(LiteralExt, CompletionItemKind.Class)]
        [DataRow(LiteralExtL, CompletionItemKind.Class)]
        [DataRow(LiteralFunc, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralFuncL, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralInd, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralIndL, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralIntr, CompletionItemKind.Struct)]
        [DataRow(LiteralIntrL, CompletionItemKind.Struct)]
        [DataRow(LiteralInf, CompletionItemKind.Class)]
        [DataRow(LiteralInfL, CompletionItemKind.Class)]
        [DataRow(LiteralLoc, CompletionItemKind.Class)]
        [DataRow(LiteralLocL, CompletionItemKind.Class)]
        [DataRow(LiteralPrty, CompletionItemKind.Value)]
        [DataRow(LiteralPrtyL, CompletionItemKind.Value)]
        [DataRow(LiteralObj, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralObjL, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralOpt, CompletionItemKind.Property)]
        [DataRow(LiteralOptL, CompletionItemKind.Property)]
        [DataRow(LiteralPred, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralPredL, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralPre, CompletionItemKind.Struct)]
        [DataRow(LiteralPreL, CompletionItemKind.Struct)]
        [DataRow(LiteralPrf, CompletionItemKind.Class)]
        [DataRow(LiteralPrfL, CompletionItemKind.Class)]
        [DataRow(LiteralRet, CompletionItemKind.Property)]
        [DataRow(LiteralRetL, CompletionItemKind.Property)]
        [DataRow(LiteralRev, CompletionItemKind.Property)]
        [DataRow(LiteralRevL, CompletionItemKind.Property)]
        [DataRow(LiteralUndef, CompletionItemKind.Constant)]
        [DataRow(LiteralUndefL, CompletionItemKind.Constant)]
        // keywords without a short form
        [DataRow(LiteralAlias, CompletionItemKind.Struct)]
        [DataRow(LiteralAll, CompletionItemKind.Operator)]
        [DataRow(LiteralAnd, CompletionItemKind.Operator)]
        [DataRow(LiteralAssL, CompletionItemKind.Property)]
        [DataRow(LiteralCases, CompletionItemKind.Property)]
        [DataRow(LiteralEx, CompletionItemKind.Operator)]
        [DataRow(LiteralExN, CompletionItemKind.Operator)]
        [DataRow(LiteralFalse, CompletionItemKind.Constant)]
        [DataRow(LiteralFor, CompletionItemKind.Property)]
        [DataRow(LiteralIif, CompletionItemKind.Operator)]
        [DataRow(LiteralImpl, CompletionItemKind.Operator)]
        [DataRow(LiteralIn, CompletionItemKind.Property)]
        [DataRow(LiteralInfix, CompletionItemKind.Operator)]
        [DataRow(LiteralIs, CompletionItemKind.Interface)]
        [DataRow(LiteralNot, CompletionItemKind.Operator)]
        [DataRow(LiteralOr, CompletionItemKind.Operator)]
        [DataRow(LiteralPostFix, CompletionItemKind.Operator)]
        [DataRow(LiteralPrefix, CompletionItemKind.Operator)]
        [DataRow(LiteralQed, CompletionItemKind.Text)]
        [DataRow(LiteralSelf, CompletionItemKind.Reference)]
        [DataRow(LiteralParent, CompletionItemKind.Reference)]
        [DataRow(LiteralSymbol, CompletionItemKind.TypeParameter)]
        [DataRow(LiteralTrivial, CompletionItemKind.Text)]
        [DataRow(LiteralTrue, CompletionItemKind.Constant)]
        [DataRow(LiteralUses, CompletionItemKind.Module)]
        [DataRow(LiteralXor, CompletionItemKind.Operator)]
        public void TestGetDetailCompletionKind(string input, CompletionItemKind expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<CompletionItemKind>(expected, actual.Kind);
        }

        [TestMethod]
        [DataRow(LiteralAx, "axiom02")]
        [DataRow(LiteralAxL, "axiom01")]
        [DataRow(LiteralPost, "postulate02")]
        [DataRow(LiteralPostL, "postulate01")]
        [DataRow(LiteralThm, "theorem02")]
        [DataRow(LiteralThmL, "theorem01")]
        [DataRow(LiteralLem, "lemma02")]
        [DataRow(LiteralLemL, "lemma01")]
        [DataRow(LiteralProp, "proposition02")]
        [DataRow(LiteralPropL, "proposition01")]
        [DataRow(LiteralCor, "corollary02")]
        [DataRow(LiteralCorL, "corollary01")]
        [DataRow(LiteralAss, "assume02")]
        [DataRow(LiteralAssume, "assume01")]
        [DataRow(LiteralCl, "class02")]
        [DataRow(LiteralClL, "class01")]
        [DataRow(LiteralConj, "conjecture02")]
        [DataRow(LiteralConjL, "conjecture01")]
        [DataRow(LiteralCon, "conclusion02")]
        [DataRow(LiteralConL, "conclusion01")]
        [DataRow(LiteralCtor, "constructor02")]
        [DataRow(LiteralCtorL, "constructor01")]
        [DataRow(LiteralDec, "declaration02")]
        [DataRow(LiteralDecL, "declaration01")]
        [DataRow(LiteralDef, "definition02")]
        [DataRow(LiteralDefL, "definition01")]
        [DataRow(LiteralDel, "delegate02")]
        [DataRow(LiteralDelL, "delegate01")]
        [DataRow(LiteralExt, "extension02")]
        [DataRow(LiteralExtL, "extension01")]
        [DataRow(LiteralFunc, "function02")]
        [DataRow(LiteralFuncL, "function01")]
        [DataRow(LiteralInd, "index02")]
        [DataRow(LiteralIndL, "index01")]
        [DataRow(LiteralIntr, "intrinsic02")]
        [DataRow(LiteralIntrL, "intrinsic01")]
        [DataRow(LiteralInf, "inference02")]
        [DataRow(LiteralInfL, "inference01")]
        [DataRow(LiteralLoc, "localization02")]
        [DataRow(LiteralLocL, "localization01")]
        [DataRow(LiteralPrty, "property02")]
        [DataRow(LiteralPrtyL, "property01")]
        [DataRow(LiteralObj, "object02")]
        [DataRow(LiteralObjL, "object01")]
        [DataRow(LiteralOpt, "optional02")]
        [DataRow(LiteralOptL, "optional01")]
        [DataRow(LiteralPred, "predicate02")]
        [DataRow(LiteralPredL, "predicate01")]
        [DataRow(LiteralPre, "premise02")]
        [DataRow(LiteralPreL, "premise01")]
        [DataRow(LiteralPrf, "proof02")]
        [DataRow(LiteralPrfL, "proof01")]
        [DataRow(LiteralRet, "return02")]
        [DataRow(LiteralRetL, "return01")]
        [DataRow(LiteralRev, "revoke02")]
        [DataRow(LiteralRevL, "revoke01")]
        [DataRow(LiteralUndef, "undefined02")]
        [DataRow(LiteralUndefL, "undefined01")]
        // keywords without a short form
        [DataRow(LiteralAlias, LiteralAlias)]
        [DataRow(LiteralAll, LiteralAll)]
        [DataRow(LiteralAnd, LiteralAnd)]
        [DataRow(LiteralAssL, LiteralAssL)]
        [DataRow(LiteralCases, LiteralCases)]
        [DataRow(LiteralEx, LiteralEx)]
        [DataRow(LiteralExN, LiteralExN)]
        [DataRow(LiteralFalse, LiteralFalse)]
        [DataRow(LiteralFor, LiteralFor)]
        [DataRow(LiteralIif, LiteralIif)]
        [DataRow(LiteralImpl, LiteralImpl)]
        [DataRow(LiteralIn, LiteralIn)]
        [DataRow(LiteralInfix, LiteralInfix)]
        [DataRow(LiteralIs, LiteralIs)]
        [DataRow(LiteralNot, LiteralNot)]
        [DataRow(LiteralOr, LiteralOr)]
        [DataRow(LiteralPrefix, LiteralPrefix)]
        [DataRow(LiteralPostFix, LiteralPostFix)]
        [DataRow(LiteralQed, LiteralQed)]
        [DataRow(LiteralSelf, LiteralSelf)]
        [DataRow(LiteralParent, LiteralParent)]
        [DataRow(LiteralSymbol, LiteralSymbol)]
        [DataRow(LiteralTrivial, LiteralTrivial)]
        [DataRow(LiteralTrue, LiteralTrue)]
        [DataRow(LiteralUses, LiteralUses)]
        [DataRow(LiteralXor, LiteralXor)]
        public void TestGetCompletionItemSortTextsForKeywords(string input, string expected)
        {
            var actual = new FplCompletionItem(input);
            Console.WriteLine(input);
            Assert.AreEqual<string>(expected, actual.SortText.Replace("zzz", ""));
        }

        [TestMethod]
        [DataRow(LiteralAx, "axiom02")]
        [DataRow(LiteralAxL, "axiom01")]
        [DataRow(LiteralPost, "postulate02")]
        [DataRow(LiteralPostL, "postulate01")]
        [DataRow(LiteralThm, "theorem02")]
        [DataRow(LiteralThmL, "theorem01")]
        [DataRow(LiteralLem, "lemma02")]
        [DataRow(LiteralLemL, "lemma01")]
        [DataRow(LiteralProp, "proposition02")]
        [DataRow(LiteralPropL, "proposition01")]
        [DataRow(LiteralCor, "corollary02")]
        [DataRow(LiteralCorL, "corollary01")]
        [DataRow(LiteralAss, "assume02")]
        [DataRow(LiteralAssume, "assume01")]
        [DataRow(LiteralCl, "class02")]
        [DataRow(LiteralClL, "class01")]
        [DataRow(LiteralConj, "conjecture02")]
        [DataRow(LiteralConjL, "conjecture01")]
        [DataRow(LiteralCon, "conclusion02")]
        [DataRow(LiteralConL, "conclusion01")]
        [DataRow(LiteralCtor, "constructor02")]
        [DataRow(LiteralCtorL, "constructor01")]
        [DataRow(LiteralDec, "declaration02")]
        [DataRow(LiteralDecL, "declaration01")]
        [DataRow(LiteralDef, "definition02")]
        [DataRow(LiteralDefL, "definition01")]
        [DataRow(LiteralDel, "delegate02")]
        [DataRow(LiteralDelL, "delegate01")]
        [DataRow(LiteralExt, "extension02")]
        [DataRow(LiteralExtL, "extension01")]
        [DataRow(LiteralFunc, "function02")]
        [DataRow(LiteralFuncL, "function01")]
        [DataRow(LiteralInd, "index02")]
        [DataRow(LiteralIndL, "index01")]
        [DataRow(LiteralIntr, "intrinsic02")]
        [DataRow(LiteralIntrL, "intrinsic01")]
        [DataRow(LiteralInf, "inference02")]
        [DataRow(LiteralInfL, "inference01")]
        [DataRow(LiteralLoc, "localization02")]
        [DataRow(LiteralLocL, "localization01")]
        [DataRow(LiteralPrty, "property02")]
        [DataRow(LiteralPrtyL, "property01")]
        [DataRow(LiteralObj, "object02")]
        [DataRow(LiteralObjL, "object01")]
        [DataRow(LiteralOpt, "optional02")]
        [DataRow(LiteralOptL, "optional01")]
        [DataRow(LiteralPred, "predicate02")]
        [DataRow(LiteralPredL, "predicate01")]
        [DataRow(LiteralPre, "premise02")]
        [DataRow(LiteralPreL, "premise01")]
        [DataRow(LiteralPrf, "proof02")]
        [DataRow(LiteralPrfL, "proof01")]
        [DataRow(LiteralRet, "return02")]
        [DataRow(LiteralRetL, "return01")]
        [DataRow(LiteralRev, "revoke02")]
        [DataRow(LiteralRevL, "revoke01")]
        [DataRow(LiteralUndef, "undefined02")]
        [DataRow(LiteralUndefL, "undefined01")]
        // keywords without a short form
        [DataRow(LiteralAlias, LiteralAlias)]
        [DataRow(LiteralAll, LiteralAll)]
        [DataRow(LiteralAnd, LiteralAnd)]
        [DataRow(LiteralAssL, LiteralAssL)]
        [DataRow(LiteralCases, LiteralCases)]
        [DataRow(LiteralEx, LiteralEx)]
        [DataRow(LiteralExN, LiteralExN)]
        [DataRow(LiteralFalse, LiteralFalse)]
        [DataRow(LiteralFor, LiteralFor)]
        [DataRow(LiteralIif, LiteralIif)]
        [DataRow(LiteralImpl, LiteralImpl)]
        [DataRow(LiteralIn, LiteralIn)]
        [DataRow(LiteralInfix, LiteralInfix)]
        [DataRow(LiteralIs, LiteralIs)]
        [DataRow(LiteralNot, LiteralNot)]
        [DataRow(LiteralOr, LiteralOr)]
        [DataRow(LiteralPrefix, LiteralPrefix)]
        [DataRow(LiteralPostFix, LiteralPostFix)]
        [DataRow(LiteralQed, LiteralQed)]
        [DataRow(LiteralSelf, LiteralSelf)]
        [DataRow(LiteralParent, LiteralParent)]
        [DataRow(LiteralSymbol, LiteralSymbol)]
        [DataRow(LiteralTrivial, LiteralTrivial)]
        [DataRow(LiteralTrue, LiteralTrue)]
        [DataRow(LiteralUses, LiteralUses)]
        [DataRow(LiteralXor, LiteralXor)]
        public void TestGetCompletionItemSortTextsForSnippets(string input, string expected)
        {
            var actual = new FplCompletionItem(input, "xxx");
            Console.WriteLine(input);
            Assert.AreEqual<string>(expected, actual.SortText);
        }


        [TestMethod]
        [DataRow(LiteralAx, true)]
        [DataRow(LiteralAxL, false)]
        [DataRow(LiteralPost, true)]
        [DataRow(LiteralPostL, false)]
        [DataRow(LiteralThm, true)]
        [DataRow(LiteralThmL, false)]
        [DataRow(LiteralLem, true)]
        [DataRow(LiteralLemL, false)]
        [DataRow(LiteralProp, true)]
        [DataRow(LiteralPropL, false)]
        [DataRow(LiteralCor, true)]
        [DataRow(LiteralCorL, false)]
        [DataRow(LiteralAss, true)]
        [DataRow(LiteralAssume, false)]
        [DataRow(LiteralCl, true)]
        [DataRow(LiteralClL, false)]
        [DataRow(LiteralConj, true)]
        [DataRow(LiteralConjL, false)]
        [DataRow(LiteralCon, true)]
        [DataRow(LiteralConL, false)]
        [DataRow(LiteralCtor, true)]
        [DataRow(LiteralCtorL, false)]
        [DataRow(LiteralDec, true)]
        [DataRow(LiteralDecL, false)]
        [DataRow(LiteralDef, true)]
        [DataRow(LiteralDefL, false)]
        [DataRow(LiteralDel, true)]
        [DataRow(LiteralDelL, false)]
        [DataRow(LiteralExt, true)]
        [DataRow(LiteralExtL, false)]
        [DataRow(LiteralFunc, true)]
        [DataRow(LiteralFuncL, false)]
        [DataRow(LiteralInd, true)]
        [DataRow(LiteralIndL, false)]
        [DataRow(LiteralIntr, true)]
        [DataRow(LiteralIntrL, false)]
        [DataRow(LiteralInf, true)]
        [DataRow(LiteralInfL, false)]
        [DataRow(LiteralLoc, true)]
        [DataRow(LiteralLocL, false)]
        [DataRow(LiteralPrty, true)]
        [DataRow(LiteralPrtyL, false)]
        [DataRow(LiteralObj, true)]
        [DataRow(LiteralObjL, false)]
        [DataRow(LiteralOpt, true)]
        [DataRow(LiteralOptL, false)]
        [DataRow(LiteralPred, true)]
        [DataRow(LiteralPredL, false)]
        [DataRow(LiteralPre, true)]
        [DataRow(LiteralPreL, false)]
        [DataRow(LiteralPrf, true)]
        [DataRow(LiteralPrfL, false)]
        [DataRow(LiteralRet, true)]
        [DataRow(LiteralRetL, false)]
        [DataRow(LiteralRev, true)]
        [DataRow(LiteralRevL, false)]
        [DataRow(LiteralUndef, true)]
        [DataRow(LiteralUndefL, false)]
        // keywords without a short form
        [DataRow(LiteralAlias, false)]
        [DataRow(LiteralAll, false)]
        [DataRow(LiteralAnd, false)]
        [DataRow(LiteralAssL, false)]
        [DataRow(LiteralCases, false)]
        [DataRow(LiteralEx, false)]
        [DataRow(LiteralExN, false)]
        [DataRow(LiteralFalse, false)]
        [DataRow(LiteralFor, false)]
        [DataRow(LiteralIif, false)]
        [DataRow(LiteralImpl, false)]
        [DataRow(LiteralIn, false)]
        [DataRow(LiteralInfix, false)]
        [DataRow(LiteralIs, false)]
        [DataRow(LiteralNot, false)]
        [DataRow(LiteralOr, false)]
        [DataRow(LiteralPrefix, false)]
        [DataRow(LiteralPostFix, false)]
        [DataRow(LiteralQed, false)]
        [DataRow(LiteralSelf, false)]
        [DataRow(LiteralParent, false)]
        [DataRow(LiteralSymbol, false)]
        [DataRow(LiteralTrivial, false)]
        [DataRow(LiteralTrue, false)]
        [DataRow(LiteralUses, false)]
        [DataRow(LiteralXor, false)]
        public void TestGetDetailIsShort(string input, bool expected)
        {
            var actual = new FplCompletionItem(input);
            Assert.AreEqual<bool>(expected, actual.IsShort);
        }
    }
}
