Fpl.SetTheory.ZermeloFraenkel
{
    uses {Fpl.Commons}
    theory
    {
        class Set: obj
        {
            intrinsic
        }

        // "in relation" ("is element of") relation
        pred In(x,y: Set)
        {
            intrinsic
        }

        pred IsEmpty(x: Set)
        {
            dec: y: Set;
            spec:;
			
            all y
            (
                not ( In(y, x) )
            )
        }

        // existence of an empty set
        axiom EmptySetExists()
        {
            dec:x: Set;
            spec:;
            ex x
            (
                IsEmpty(x)
            )
        }

        // introduction of a new mathematical object
        class EmptySet: Set
        {
            dec:;
            spec:;
            EmptySet()
            {
                dec:;
                spec:
                assert IsEmpty(self);
            }
        }

        // relation between a subset and a superset
        pred IsSubset(subset,superset: Set)
        {
            dec:u: Set;
            spec:;
            all u
            (
                impl (In(u, subset), In(u, superset))
            )
        }

        // introduction of a new mathematical object that is a subset of a superset
        class Subset: Set
        {
            dec:;
            spec:;
            Subset(superSet: Set)
            {
                dec:;
                spec:
                assert IsSubset(self, superSet);
            }
        }

        // extensionality
        axiom Extensionality()
        {
            dec:x,y: Set;
            spec:;
            all x,y
            (
                impl
                (
                    and
                    (
                        IsSubset(x,y),
                        IsSubset(y,x)
                    ),
                    Equal(x,y)
                )
            )
        }

        // adds Roster notation capability to this theory
        class SetRoster: Set
        {
            // to support enumerating set elements, e.g. SetRoster(1,2,3)
            dec:;
            spec:;
            SetRoster(listOfSets:* Set)
            {
                dec:elem: Set;
                spec:

                loop elem listOfSets
                (
                    assert In(elem, self)
                );
            }

        }

        // Schema of separation axioms
        axiom SchemaSeparation()
        {
            dec:
                p: pred
                x,y: Set
                ;
            spec:;
            all p, x
            (
                ex y
                (
                    Equal(y,SetBuilder(x,p))
                )
            )
        }

        // adds set-builder notation capability to this theory
        // pred p indicates that p is a predicate, in which the variable u is bound and the type of u is Set
        // moreover, p can accept even more bound variables of any type.
        class SetBuilder: Set
        {
            // to support set builder notation, ex. all "even" natural numbers like SetBuilder(n: Nat, Even(n))
            dec:;
            spec:;
            SetBuilder(x: Set, p: pred(u: Set, o:* obj))
            {
                dec:;
                spec:
                assert
                    all u
                    (
                        iif
                        (
                            In(u,self),
                            and ( In(u,x), p(u,o) )
                        )
                    )
                ;
            }
        }

        // For any two sets $x,y$ there exists a set $z$ containing them as elements.
        axiom Pairing()
        {
            dec:x,y,z,w: Set;
            spec:;
            all x,y
            (
                ex z
                (
                    all w
                    (
                        iif
                        (
                            In(w,z),
                            or
                            (
                                Equal(w,x),
                                Equal(w,y)
                            )
                        )
                    )
                )
            )
        }

        // for every set x there is a set containing all elements of the elements of x
        axiom Union()
        {
            dec:x,y,z,w: Set;
            spec:;
            all x
            (
                ex y
                (
                    all z,w
                    (
                        impl
                        (
                            and (In(z,w), In(w,x)),
                            In (z,y)
                        )
                    )
                )
            )
        }

        pred IsPowerSet(ofSet, potentialPowerSet: Set)
        {
            dec:z: Set;
            spec:;
            all z
            (
                impl (Subset(z,ofSet), In(z, potentialPowerSet))
            )
        }

        // including the PowerSet function
        func PowerSet(x: Set) -> Set
        {
            dec:
                y: Set
                ;
            spec:
                assert IsPowerSet(x,y)
                ;
                y
        }

        // for every set x there is a set y containing all subsets of x as its elements
        axiom PowerSetExistsForAllSets()
        {
            dec:
            x,y: Set;
            spec:;
            all x
            (
                ex y
                (
                    IsPowerSet(x, y)
                )
            )
        }

        // introducing a set union function
        func SetUnion(x,y: Set) -> Set
        {
            dec:z, union: Set;
            spec:
            assert
                all z
                (
                    iif
                    (
                        or (In(z,x), In(z,y)),
                        In(z,union)
                    )
                )
            ;
            union
        }

        // introducing a singleton function
        func Singleton(x: Set) -> Set
        {
            dec:;
            spec:;
            SetRoster(x)
        }

        // alternative 2: adds SetUnion notation capability to this theory (as predicate)
        pred Union(x,superSet: Set)
        {
            dec:u: Set;
            spec:;
            all u
            (
                impl (In(u, x), In(u, superSet))
            )
        }


    }
}
