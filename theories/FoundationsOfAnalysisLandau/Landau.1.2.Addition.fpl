uses Fpl.SetTheory
uses Landau *

// If x <> y then succesor of x <> successor of y.
theorem Theorem_001()
{
    dec ~x,y: Nat; // PoC's note: FPL makes the distinction between the set N and the class Nat of a natural number explicit!
    impl
    (
        // if
        not ( < x = y > )
        , // then
        not ( < Successor(x) = Successor(y) > )
    )
}


proof Theorem_001$1
{
    // Proof by Contradiction (Type 2)
    // Strategy: Assume that the premise is true and the conclusion is false.
    // Then derive a contradiction.

    100. |- assume 
            and
            (
                not ( < x = y > )
                , 
                < Successor(x) = Successor(y) >
            )
    200. Axiom4() |- < x = y >
    300. |- revoke 100.
    400. |- qed
}

// The successor (x) never equals x 
theorem Theorem_002 ()
{
    dec ~x: Nat;
    not
    (
        < Succesor(x) = x > 
    )
}

proof Theorem_002$1
{
    // Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( AddNat(n,1) )` is true.
    
    // "base case" 
    100. and (Axiom1(), Axiom3()) |- not ( < Succesor(1) = 1 > )
    
    // "inductive step" 
    200. |- assume ex n in N ( not ( < Succesor(n) = n > ) )
    300. Theorem_001() |- not ( < Successor(Succesor(n)) = Successor(n) > )
    
    400. and(100., 400.) 
        |- all x in N 
        (
            not ( < Succesor(x) = x > ) 
        )
    500. |- qed
}
    
// If x <> 1, then there exists one (hence by Axiom 4, exactly one) predecessor u of x, i.e. successor (u) = x.
theorem Theorem_003 ()
{
    dec ~x,u: Nat;

    impl
    (
        not (< x = 1 >)
        ,
        exn$1 u in N
        (
            < Succesor(u) = x >
        )
    )
}

proof Theorem_003$1
{
    // Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( AddNat(n,1) )` is true.
    
    dec 
         ~x : object
         ~m : Set // let m be a set 
         assert In (1, m) // such that 1 belongs to m
         assert 
            // and of all those x for which there exists such u.
            // PoC note: We formalize the notion "for which there exists such u" by the following implication
            impl
            (
                // if for some x the premise holds
                impl
                (
                    not (< x = 1 >) 
                    ,
                    exn$1 u in N
                    (
                        < Succesor(u) = x >
                    )
                )
                ,
                // then it belongs to the set m
                In (x, m)
            )
    ;

    // "base case" 
    100. |- In(1, m)
    200. |- trivial
    
    // "inductive step" 
    300. 200. |- assume In (x, m)
    400. |- exn$1 u in N
                    (
                        < Succesor(u) = x >
                    )
    500. Axiom3(), Axiom2() |- < Successor(Successor(u)) = Sucessor(x) >
    600. bydef m |- In(Successor(x), m)
    700. |- < m = N >
    800. |- qed
}

// PoC note: In Landau's original, Theorem 4 is formulated as "at the same time Definition 1". In FPL, we deal with theorems and definitions separately,
// making it more transparent, what is part of a constructive definition and what is the predicative expression about it in the theorem.  

// Theorem 3, and at the same time definition 1: To every pair of number x,y, we can assign in exactly one way a natural number, called x + y such that 
// (1) x + 1 = successor of x for every x
// (2) x + y = successor of (x + y)
// x + y is called the sum of x and y, or the number obtained by addition of y to x.

definition function Sum(x,y: Nat) -> Nat
{
    declaration
        ~res: Nat
        cases
        (
            | < y = 1 > : res := Successor(x) 
            ? res := Successor( Sum(x,y) )
        )
    ;
    return res
}

// PoC note: After defining what Sum is, we now simply state its uniqueness predicatively
theorem Theorem_004 ()
{
    declaration
        ~sum, otherSum: Sum
    ;
    
    all x,y in Nat
    (
        < sum(x,y) = otherSum(x,y) >
    )
}

proof SomeFplTheorem$1
{
    // Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( AddNat(n,1) )` is true.
    
    dec 
         ~x : N // for a fixed x

        // and for all y we define
        for y in N 
        (
            a!1 := Successor(x)
            b!1 := Successor(x)
            a!Successor(y) := Successor(a!y)
            b!Successor(y) := Successor(b!y)
        )
    ;

    // "base case" 
    100. |- trivial
    200. |- p(1)
    
    // "inductive step" 
    300. 200. |- assume ex n in N ( p(n) )
    400. |- trivial
    500. |- trivial
    600. |- p( AddNat(n,1) )
    
    700. |- all n in N ( p(n) )
    800. |- qed
}



;