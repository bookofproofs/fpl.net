uses Fpl.SetTheory
uses Landau *

// If x <> y then succesor of x <> successor of y.
theorem Theorem_001()
{
    dec ~x,y: Nat; // PoC's note: FPL makes the distinction between the set N and the class Nat of a natural number explicit!
    impl
    (
        // if
        not ( < x = y > )
        , // then
        not ( < Successor(x) = Successor(y) > )
    )
}


proof Theorem_001!$1
{
    // PoC note: Proof by Contradiction (Type 2)
    // Strategy: Assume that the premise is true and the conclusion is false.
    // Then derive a contradiction.

    100. |- assume 
            and
            (
                not ( < x = y > )
                , 
                < Successor(x) = Successor(y) >
            )
    200. Axiom4() |- < x = y >
    300. |- revoke 100.
    400. |- qed
}

// The successor (x) never equals x 
theorem Theorem_002 ()
{
    dec ~x: Nat;
    not
    (
        < Succesor(x) = x > 
    )
}

proof Theorem_002!$1
{
    // PoC note: Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( AddNat(n,1) )` is true.
    
    // "base case" 
    100. and (Axiom1(), Axiom3()) |- not ( < Succesor(1) = 1 > )
    
    // "inductive step" 
    200. |- assume ex n in N ( not ( < Succesor(n) = n > ) )
    300. Theorem_001() |- not ( < Successor(Succesor(n)) = Successor(n) > )
    
    400. and(100., 400.) 
        |- all x in N 
        (
            not ( < Succesor(x) = x > ) 
        )
    500. |- qed
}
    
// If x <> 1, then there exists one (hence by Axiom 4, exactly one) predecessor u of x, i.e. successor (u) = x.
theorem Theorem_003 ()
{
    dec ~x,u: Nat;

    impl
    (
        not (< x = 1 >)
        ,
        exn$1 u in N
        (
            < Succesor(u) = x >
        )
    )
}

proof Theorem_003!$1
{
    // PoC note: Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( AddNat(n,1) )` is true.
    
    dec 
         ~x : object
         ~m : Set // let m be a set 
         assert In (1, m) // such that 1 belongs to m
         assert 
            // and of all those x for which there exists such u.
            // PoC note: We formalize the notion "for which there exists such u" by the following implication
            impl
            (
                // if for some x the premise holds
                impl
                (
                    not (< x = 1 >) 
                    ,
                    exn$1 u in N
                    (
                        < Succesor(u) = x >
                    )
                )
                ,
                // then it belongs to the set m
                In (x, m)
            )
    ;

    // "base case" 
    100. |- In(1, m)
    200. |- trivial
    
    // "inductive step" 
    300. 200. |- assume In (x, m)
    400. |- exn$1 u in N
                    (
                        < Succesor(u) = x >
                    )
    500. Axiom3(), Axiom2() |- < Successor(Successor(u)) = Sucessor(x) >
    600. bydef m |- In(Successor(x), m)
    700. |- < m = N >
    800. |- qed
}

// PoC note: In Landau's original, Theorem 4 is formulated as "at the same time Definition 1". In FPL, we deal with theorems and definitions separately,
// making it more transparent, what is part of a constructive definition and what is the predicative expression about it in the theorem.  

// Theorem 3, and at the same time definition 1: To every pair of number x,y, we can assign in exactly one way a natural number, called x + y such that 
// (1) x + 1 = x' for every x
// (2) x + y = (x + y)'
// x + y is called the sum of x and y, or the number obtained by addition of y to x.

definition function Sum(x,y: Nat) -> Nat
{
    declaration
        ~res: Nat
        cases
        (
            | < y = 1 > : res := Successor(x) 
            ? Sum (x, Successor(y)) := Successor( Sum(x,y) )
        )
    ;
    return res
}

// PoC note: Landau 'proves' the definition in one proof splitting it into the parts A and B. In fact, he proves that the way he defines Sum is 'well-defined'
// i.e. it exists and is unique
// In FPL, we formulate for these parts lemmas and them prove them. Finally, we prove the Theorem_004 using the lemmas
// This makes the prove longer on one hand but more clear on the other hand.
// (PoC note: In modern terms, Landau shows the uniqueness Sum is actually a function, i.e. that it produces at most one result, is unique)
lemma Theorem_004_A ()
{
    // (A) We first show that for fixed x there is at most one possibility of defining x + y for all y such that x + 1 = successor(x) and x + successor(y) = successor (x, y)
    declaration 
         ~x : N // for a fixed x
    ;

    and (
        < Sum(x, 1) = Successor(x) > 
        , 
        all y in N 
        ( 
            < Sum(x,Successor(y)) = Successor(x,y) > 
        ) 
    )
}

proof Theorem_004_A!$1
{
    // PoC note: Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( Sum(n,1) )` is true.
    
    declaration 
         ~x : N // for a fixed x
        // and for all y we define 
        for y in N 
        (
            // such that
            a!1 := Successor(x) 
            b!1 := Successor(x)
            a!Successor(y) := Successor(a!y)
            b!Successor(y) := Successor(b!y)
        )
    ;
    declaration
         ~m : Set // let m be a set 
         assert 
            // Let m be the set of all y 
            // for which a!y = b!y and a!1 = successor(x) = b!1
            iif
            (
                < a!y = b!y >
                ,
                // PoC note: We formulate it predicatively using the implication that if the conjugated premise is fulfilled for some x than x is element of m
                In (y, m)
            )
    ;
    
    // "base case" 
    100. bydef a!1, bydef b!1 |- < a!1 = Successor(x) = b!1 >
    100. |- < a!1 = b!1 >
    200. bydef m |- In (1, m)
    
    // "inductive step" 
    300. 200. |- assume ex y ( In(y,m) ) // if y belongs to m
    400. bydef m |- < a!y = b!y > 
    500. Axiom2 |- 
        < Successor(a!y) = Successor(b!y) > 
    600. bydef a!Successor(y), bydef b!Successor(b) |- 
        < a!Successor(y) = Successor(a!y) = Successor(b!y) = b!Successor(y) >
    650. |- In(Successor(y), m)
    
    700. |- all y in N ( < a!y = b!y > )
    800. |- qed
}

// PoC note: In modern terms, Landau shows the existence of the function Sum
lemma Theorem_004_B ()
{
    // (B) Now we will prove that for each x it is actually possible to define x + y for all y in such a way that 
    // x + 1 = successor(x) and x + successor(y) = successor (x + y) for every y.
    // PoC note: We reformulate it predicatively
    all x,y in N
    (
        and 
        (
            < Sum(x, 1) = Successor (x) >
            ,
            < Sum(x, Successor(y)) = Successor (x, y) > 
        )
    )
}



proof Theorem_004_B!$1
{
    // PoC note: Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( AddNat(n,1) )` is true.
    
    // Let m be the set all x for which this is possible.

    declaration
         ~m : Set 
         assert 
            impl
            (
                all x,y in N
                (
                    and 
                    (
                        < Sum(x, 1) = Successor (x) >
                        ,
                        < Sum(x, Successor(y)) = Successor (x, y) > 
                    )
                )
                ,
                In (x, m)
            )
    ;

    // "base case" 
    // For x = 1 the number x + y = successor(y) is as required
    100. |- assume <x = 1> 
    110. 100., bydef Sum |- 
        < Sum(x, 1) = Successor (x) > // since x + 1 = successor(1) = successor (x) and 
    150. 100., bydef Sum |- 
        // (x+y') = (y')' = (x+y)'
        < Sum (x, Successor(y)) = Successor(Successor(y)) = Successor (x,y) >
    200. |- In (1,m) // hence 1 belongs to m
    
    // "inductive step" 
    300. 200. |- assume ex x ( In (x, m) ) // let x belong to m, so that there exists an x + y for all y. Then the number x'+ y = (x + y)' is the required number for x'  
    400. bydef Sum |- 
        < Sum(Successor (x), 1) = Successor(Sum(x,1)) = Successor(Successor(x)) > // since x' + 1 = (x+1)' = (x')'

    500. bydef Sum |- 
        // and x' + y' = (x+y')' = ((x+y)')' = (x'+y)' 
        < Sum(Successor(x), Successor(y)) = Successor(Sum(x, Successor(y))) = Successor(Successor(x,y)) = Successor(Sum (Successor(x), y)) > 
    600. |- In (Successor(x), m) // hence, x' belongs to m
    800. |- qed
}

// (Associative Law of Addition)
theorem Theorem_005_SumIsAssoziative ()
{
    < Sum(Sum(x,y),z) = Sum(x,Sum(y,z)) > 
}

proof Theorem_005_SumIsAssoziative!$1
{
    // Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( Sum(n,1) )` is true.
    
    dec 
         ~x,y,z : N // Fix x and y.
         ~m : Set 
         // Denote by m the set of all z for which the assertion of the theorem holds
         assert 
            impl
            (
                < Sum(Sum(x,y),z) = Sum(x,Sum(y,z)) > 
                ,
                In (z, m)
            )
    ;

    // "base case" 
    // (x + y) + 1 = (x + y)' = x + y' = x + (y + 1)
    100. bydef Sum |- < Sum(Sum(x,y),1) = Successor(Sum(x,y)) = Sum(x, Successor(y)) = Sum(x, Sum(y,1)) > 
    200. |- In (1, m)
    
    // "inductive step" 
    300. 200. |- assume ex x ( < Sum(Sum(x,y),z) = Sum(x,Sum(y,z)) > )
    400. |- < 
              Sum( Sum(x,y), Successor (z) )    //   (x+y) + z' 
            = Successor( Sum(Sum(x,y), z) )     // = ((x+y) + z)'
            = Successor( Sum(x, Sum(y,z)) )     // = (x + (y + z))'
            = Sum( x, Successor(Sum(y,z)) )     // = x + (y+z)'
            = Sum( x, Sum(y, Successor (y)))    // = x + (y + z')
            >
    600. |- In (Successor(z), m)
    800. |- qed
}

// (Commutative Law of Addition)
theorem Theorem_006_SumIsCommutatitve ()
{
    < Sum(x,y) = Sum(y,x) > 
}

proof Theorem_006_SumIsCommutatitve!$1
{
    // Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( Sum(n,1) )` is true.
    
    dec 
         ~x, y : N // Fix x.
         ~m : Set 
         // Let m be the set of all y for which the assertion of the theorem holds
         assert 
            impl
            (
                < Sum(x,y) = Sum(y,x) >
                ,
                In (z, m)
            )
    ;

    // "base case" 
    100. bydef Sum |- < Sum(y,1) = Successor(Sum(y)) > // We have y + 1 = y', 
    110. Theorem_004_B!$1 |- <Sum(1,y) = Successor(Sum(y)) >  // by the construction in the proof of Theorem 4, 1 + y = y'
    150. 100., 110. |- < Sum(y,1) = Sum(1,y) > // so that 1 + y = y + 1
    200. |- In (1, m) // and 1 belongs to m.
    
    // "inductive step" 
    300. 200. |- assume ex x ( In (x, m) ) // If x belongs to m,
    400. |- < Sum(x,y) = Sum(y,x) >
    450. |- <    //   then x + y = y + x
            Successor( Sum(x,y) )     // therefore (x + y)' = (y+x)' = y + x'
            = Successor( Sum(y,x) )  
            = Sum( x, Successor(y) )     
            >
    470. Theorem_004_B!$1 |- <Sum(Successor(x),y) = Successor(Sum(x,y)) >  // by the construction in the proof of theorem 4, we have x' + y = (x + y)'.
    500. |- <Sum(Successor(x),y) = Sum(y, Successor(x))> // hense x' + y = y + x'
    600. |- In (Successor(x), m) // so that x' belongs to m
    800. |- qed
}

theorem Theorem_007 ()
{
    not
    (
        < y = Sum(x,y) > 
    )
}

proof SomeFplTheorem!$1
{
    // Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( Sum(n,1) )` is true.
    
    dec 
         ~n : N
    ;
    // "base case" 
    100. |- trivial
    200. |- p(1)
    
    // "inductive step" 
    300. 200. |- assume ex n in N ( p(n) )
    400. |- trivial
    500. |- trivial
    600. |- p( Sum(n,1) )
    
    700. |- all n in N ( p(n) )
    800. |- qed
}


;