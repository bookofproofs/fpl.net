inf AndCummutative
{
    dec ~p, q: pred;
    pre:
        and(p, q)
    con:
        and(q, p)
}

inf OrCummutative
{
    dec ~p, q: pred;
    pre:
        or(p, q)
    con:
        or(q, p)
}

inf XorCummutative
{
    dec ~p, q: pred;
    pre:
        xor(p, q)
    con:
        xor(q, p)
}

inf IifCummutative
{
    dec ~p, q: pred;
    pre:
        iif(p, q)
    con:
        iif(q, p)
}

inf AndAssociative
{
    dec ~p, q, s: pred;
    pre:
        and(p, and(q, s))
    con:
        and(and (p, q), s)
}

inf OrAssociative
{
    dec ~p, q, s: pred;
    pre:
        or(p, or(q, s))
    con:
        or(or (p, q), s)
}

inf XorAssociative
{
    dec ~p, q, s: pred;
    pre:
        xor(p, xor(q, s))
    con:
        xor(xor (p, q), s)
}

inf IifAssociative
{
    dec ~p, q, s: pred;
    pre:
        iif(p, iif(q, s))
    con:
        iif(iif (p, q), s)
}

inf FalseAndAbsorbing
{
    dec ~p: pred;
    pre:
        and(false, p)
    con:
        false
}

inf TrueOrAbsorbing
{
    dec ~p: pred;
    pre:
        or(true, p)
    con:
        true
}

inf OrAndAbsorbing
{
    dec ~p, q: pred;
    pre:
        or(p, and (p, q))
    con:
        p
}

inf AndOrAbsorbing
{
    dec ~p, q: pred;
    pre:
        and(p, or (p, q))
    con:
        p
}

inf AndTrueNeutral
{
    dec ~p: pred;
    pre:
        and(true, p)
    con:
        p
}

inf OrFalseNeutral
{
    dec ~p: pred;
    pre:
        or(false, p)
    con:
        p
}

inf AndInversion
{
    dec ~p: pred;
    pre:
        and(p, not p)
    con:
        false
}

inf OrInversion
{
    dec ~p: pred;
    pre:
        or(p, not p)
    con:
        true
}

inf AndIdempotence
{
    dec ~p: pred;
    pre:
        and(p, p)
    con:
        p
}

inf OrIdempotence
{
    dec ~p: pred;
    pre:
        or(p, p)
    con:
        p
}

inf OrAndDistributiveUnpack
{
    dec ~p, q, s: pred;
    pre:
        or(p, and(q, s))
    con:
        and(or(p, q), or(p, s))
}

inf AndOrDistributivePack
{
    dec ~p, q, s: pred;
    pre:
        and(or(p, q), or(p, s))
    con:
        or(p, and(q, s))
}

inf AndOrDistributiveUnpack
{
    dec ~p, q, s: pred;
    pre:
        and(p, or(q, s))
    con:
        or(and(p, q), and(p, s))
}

inf OrAndDistributivePack
{
    dec ~p, q, s: pred;
    pre:
        or(and(p, q), and(p, s))
    con:
        and(p, or(q, s))
}

inf DeMorganAndUnpack
{
    dec ~p, q: pred;
    pre:
        not and(p, q)
    con:
        or (not p, not q)
}

inf DeMorganOrPack
{
    dec ~p, q: pred;
    pre:
        or (not p, not q)
    con:
        not and(p, q)
}

inf DeMorganOrUnpack
{
    dec ~p, q: pred;
    pre:
        not or(p, q)
    con:
        and (not p, not q)
}

inf DeMorganAndPack
{
    dec ~p, q: pred;
    pre:
        and (not p, not q)
    con:
        not or(p, q)
}

inf NotDouble
{
    dec ~p: pred;
    pre:
        not not p
    con:
        p
}

inf ImplUnpack2Or
{
    dec ~p, q: pred;
    pre:
        impl (p, q)
    con:
        or (not p, q)
}

inf OrPack2Impl
{
    dec ~p, q: pred;
    pre:
        or (not p, q)
    con:
        impl (p, q)
}

inf IifUnpack2Or
{
    dec ~p, q: pred;
    pre:
        iif(p, q)        
    con:
        or(and(not p, not q), and(p, q))
}

inf IifUnpack2And
{
    dec ~p, q: pred;
    pre:
        iif(p, q)        
    con:
        and(or(not p, q), or(p, not q))
}

inf OrPack2Iif
{
    dec ~p, q: pred;
    pre:
        or(and(not p, not q), and(p, q))
    con:
        iif(p, q)        
}

inf AndPack2Iif
{
    dec ~p, q: pred;
    pre:
        and(or(not p, q), or(p, not q))
    con:
        iif(p, q)        
}

inf XorUnpack2Or
{
    dec ~p, q: pred;
    pre:
        xor(p, q)        
    con:
        or(and(not p, q), and(p, not q))
}

inf XorUnpack2And
{
    dec ~p, q: pred;
    pre:
        xor(p, q)        
    con:
        and(or(not p, not q), or(p, q))
}

inf AndPack2Xor
{
    dec ~p, q: pred;
    pre:
        and(or(not p, not q), or(p, q))
    con:
        xor(p, q)        
}

inf OrPack2Xor
{
    dec ~p, q: pred;
    pre:
        or(and(not p, q), and(p, not q))
    con:
        xor(p, q)        
}

inf Proceeding2Results
{
    dec ~p, q: pred;
    pre:
        p, q
    con:
        and(p, q)        
}

inf Proceeding3Results
{
    dec ~p, q, s: pred;
    pre:
        p, q, s
    con:
        and(and(p, q), s)        
}

inf AndUnpack2NotOr
{
    dec ~p, q: pred;
    pre:
        and(p, q)
    con:
        not(or(not p, not q))        
}

inf NotOrPack2And
{
    dec ~p, q: pred;
    pre:
        not(or(not p, not q))        
    con:
        and(p, q)
}

inf AndUnpack2NotImpl
{
    dec ~p, q: pred;
    pre:
        and(p, q)
    con:
        not(impl(p, not q))        
}

inf NotImplPack2And
{
    dec ~p, q: pred;
    pre:
        not(impl(p, not q))        
    con:
        and(p, q)
}

inf OrUnpack2Impl
{
    dec ~p, q: pred;
    pre:
        or(p, q)        
    con:
        impl(not p, q)
}

inf ImplPack2Or
{
    dec ~p, q: pred;
    pre:
        impl(not p, q)
    con:
        or(p, q)        
}

inf ModusPonens
{
    dec ~p,q: pred;

    pre:
        p, impl (p, q)
    con:
        q
}

inf ModusTollens
{
    dec ~p,q: pred;

    pre:
        not q, impl(p, q)
    con:
        not (p)
}

inf HypotheticalSyllogism
{
    dec ~p ,q, s: pred;
    pre:
        impl(p, q), impl(q, s)
    con:
        impl(p,s)
}

inf DisjunctiveSyllogism
{
    dec ~p, q: pred;
    pre:
        not p, or(p, q)
    con:
        q
}

inf ExistsByExample
{
    dec ~p: pred(c: obj);
    pre:  
        p(c)
    con: 
        ex x:obj {p(x)}
}

inf Contraposition
{
    dec ~p,q: pred;
    pre:
        impl(not p, not q)
    con:
        impl(q, p)
}

inf WeakeningRule
{
    dec ~p,q: pred;
    pre:
        p
    con:
        impl(q, p)
}

def pred Equal(x,y: tpl) infix "=" 50 
{
    del.Equal(x,y)
}

def pred NotEqual(x,y: tpl) infix "<>" 60 
{
    not (x = y) 
}

def pred Implies(x,y: pred) infix "=>" 70 
{
    impl
    (
        x
        ,
        y
    )
}

def pred IfAndOnlyIf(x,y: pred) infix "<=>" 80
{
    iif
    (
        x
        ,
        y
    )
}

def pred And(x,y: pred) infix "and" 7 
{
    and(x,y)
}

def pred Or(x,y: pred) infix "or" 10 
{
    or(x,y)
}

def pred Xor(x,y: pred) infix "xor" 20 
{
    xor(x,y)
}

localization iif(x,y) :=
    !tex: x "\Leftrightarrow" y
    !eng: x " if and only if " y
    !ger: x " dann und nur dann wenn " y
    ;

loc not(x) :=
    !tex: "\neg(" x ")"
    !eng: "not " x
    !ger: "nicht " x
    ;

loc and(p,q) :=
    !tex: p "\wedge" q
    !eng: p " and " q
    !ger: p " und " q
    ;

loc Equal(x,y) :=
    !tex: x "=" y
    !eng: x " equals " y
    !ger: x " ist gleich " y
    !ita: x " è uguale a " y
    !pol: x " równa się " y
    ;

loc NotEqual(x,y) :=
    !tex: x "\neq" y 
    !eng: x "is unequal" y 
    !ger: x "ist ungleich" y 
    !pol: x ( "nie równa się" | "nie równe" ) y 
    ;

;