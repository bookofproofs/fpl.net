Fpl.LinAlg
{
    uses {Fpl.Commons, Fpl.Commons.Structures, Fpl.SetTheory.ZermeloFraenkel, Fpl.Algebra.Structures}
    theory
    {

        class FieldPowerN: Set
        {
			dec:
            myField: Field
			addInField: BinOp
			mulInField: BinOp
            ;
            FieldPowerN
            (
                field : Field,
                n: Nat
            )
            {
                dec:;
                spec: 
                    myField := field
                    addInField := myField.AddOp()
                    mulInField := myField.MulOp()
                    assert NotEqual(n, Zero())
                    self:=SetBuilder( myField[1 ~ n], true);
            }

	        mand func VecAdd(from,to: Nat, v,w: tplFieldElem[from ~ to]) -> tplFieldElem[from ~ to]
	        {
	            dec:;
                spec:
                    self[from ~ to]:=addInField(v[from ~ to],w[from ~ to])
                ;
	        }

        }
		
        lemma VecAddIsCommutative()
        {
            dec:
                to: Nat
                x,y: tplFieldElem[1~to]
                fieldPowerN: FieldPowerN
                    (
                    field: Field(f: tplFieldSet, opAdd, opMul: BinOp(a,b: tplFieldElem)),
                    n:Nat
                    )
                vecAdd: VecAdd(v,w: tplFieldElem[from~to]);
            spec:;
            pre:
                and
                (
                    In(x, fieldPowerN),
                    In(y, fieldPowerN)
                )
            con:
                vecAdd.IsCommutative()
        }

        class ZeroVectorN: Tuple
        {
            dec:;
            spec:;
            ZeroVectorN(n: Nat, field: Field)
            {
                dec:
                i: Nat;
                spec:
                range i [1~n]
                (
                    self<i>:=field.AdditiveGroup().NeutralElement()
                );
            }
        }
    }
}












