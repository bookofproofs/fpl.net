
/* This is a formulation of Edmund Landau's "Foundations of Analysis" (1930 Leipzig) in FPL (the Formal Proving Language).
The namespace serves as a "proof of concept" for the language. */


/* 1. AXIOMS */

definition class One: object
{
    intrinsic
}

// introduction of new symbols 1,2,3,.... and identyfying then with natural numbers of 
def class N: obj
{
    // explicit representation of a specific natural number
    ctor N(x: @Digits)
    {
        dec
            cases
            (
                | <x = 1> : self := One() 
                | <x = 2> : self := Succ(One()) 
                | <x = 3> : self := Succ(Succ(One())) 
                ? self := Succ(delegate.decrement(x))  
            )
        ;
        self
    }
}

// 1 is a natural number
axiom Axiom1 ()
{
    is (1, N) 
}

definition function Successor(x: N) -> N
{
    intrinsic
}


// For each x there exists exactly one natural number, called the successor of x, the will be denoted x
axiom Axiom2 ()
{
    all x in N
    (
        exn!1 y in N
        (
            < y = Successor(x) > 
        )
    )
}

// It follows immediately ...
corollary Axiom2!1 ()
{
    dec ~x,y:N ;
    impl
    (
        < x = y > 
        ,
        < Successor(x) = Successor(y) > 
    )
}

// There is no number whose successor is 1.
axiom Axiom3 ()
{
    dec ~x:N ;
    not 
    (
        < Successor(x) = 1 > 
    )
}

// Successor is injective
axiom Axiom4 ()
{
    dec ~x,y:N ;
    impl
    (
        < Successor(x) = Successor(y) >, 
        < x = y >
    )
}

// Axiom of Induction:
// Note: Landau's original axiom declaration is based on set-theory that we do no want to imply here.
// Therefore, our axiom definition is a little different and relays only on the syntax of FPL, not the semantics of set theory   
axiom Axiom5 () 
{
    all p in predicate // For all predicates p it holds that:
    (
        impl
        (
            // if 
            and 
            ( 
                p(One) // a predicate p is true for One 
                , // and 
                all x in object  // and for all objects x (kind of which is whatsoever) 
                ( 
                    impl 
                    ( 
                        p(x), // the truth of p for x implies
                        p(Successor(x)) // the truth of p also for x's successor
                    ) 
                )
            )
            , // then, p is actually true for all natural numbers
            all n in N 
            ( 
                p(n) 
            )
        )
    )
    // This means that our (whatsoever objects) are actually the natural numbers themselves.
}


/* 2. ADDITION */

// If x <> y then succesor of x <> successor of y.
theorem Theorem_001()
{
    dec ~x,y: N;
    impl
    (
        // if
        not ( < x = y > )
        , // then
        not ( < Successor(x) = Successor(y) > )
    )
}


proof Theorem_001!1
{
    // Proof by Contradiction (Type 2)
    // Strategy: Assume that the premise is true and the conclusion is false.
    // Then derive a contradiction.

    100. |- assume 
            and
            (
                not ( < x = y > )
                , 
                < Successor(x) = Successor(y) >
            )
    200. Axiom4() |- < x = y >
    300. |- revoke 100.
    400. |- qed
}

// The successor (x) never equals x 
theorem Theorem_002 ()
{
    dec ~x: N;
    not
    (
        < Succesor(x) = x > 
    )
}

proof Theorem_002!1
{
    // Proof by Induction (to prove: `all n in N ( p(n) )`)
    // Strategy: Prove the "base case": p(1)
    // Then do the "inductive step": Prove that if `p(n)` is true, then also `p( AddNat(n,1) )` is true.
    
    // "base case" 
    100. and (Axiom1(), Axiom3()) |- not ( < Succesor(1) = 1 > )
    
    // "inductive step" 
    200. |- assume ex n in N ( not ( < Succesor(n) = n > ) )
    300. Theorem_001() |- not ( < Successor(Succesor(n)) = Successor(n) > )
    
    400. and(100., 400.) 
        |- all x in N 
        (
            not ( < Succesor(x) = x > ) 
        )
    500. |- qed
}
    
// If x <> 1, then there exists one (hence by Axiom 4, exactly one) i such that x = successor (u)
theorem Theorem_003 ()
{
    dec ~x,y: N;

    impl
    (
        not (< x = 1 >)
        ,
        exn!1 u in N
        (
            < x = Succesor(u) >
        )
    )
}
